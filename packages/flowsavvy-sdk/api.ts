/* tslint:disable */
/* eslint-disable */
/**
 * FlowSavvy API
 * API for managing tasks, events, and schedules on FlowSavvy.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AllDayEvent
 */
export interface AllDayEvent {
    /**
     * 
     * @type {number}
     * @memberof AllDayEvent
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof AllDayEvent
     */
    'Title'?: string;
    /**
     * 
     * @type {string}
     * @memberof AllDayEvent
     */
    'StartDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof AllDayEvent
     */
    'EndDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof AllDayEvent
     */
    'Color'?: string | null;
}
/**
 * 
 * @export
 * @interface ApiAccountLoginPost200Response
 */
export interface ApiAccountLoginPost200Response {
    /**
     * 
     * @type {string}
     * @memberof ApiAccountLoginPost200Response
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface Calendar
 */
export interface Calendar {
    /**
     * 
     * @type {number}
     * @memberof Calendar
     */
    'calendarAccountId'?: number;
    /**
     * 
     * @type {string}
     * @memberof Calendar
     */
    'Title'?: string;
    /**
     * 
     * @type {string}
     * @memberof Calendar
     */
    'Color'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Calendar
     */
    'Hidden'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Calendar
     */
    'Source'?: string;
    /**
     * 
     * @type {string}
     * @memberof Calendar
     */
    'sourceUrl'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Calendar
     */
    'refreshRate'?: number;
    /**
     * 
     * @type {string}
     * @memberof Calendar
     */
    'syncId'?: string;
    /**
     * 
     * @type {number}
     * @memberof Calendar
     */
    'AccessLevel'?: number;
    /**
     * 
     * @type {string}
     * @memberof Calendar
     */
    'SyncStatus'?: string;
    /**
     * 
     * @type {number}
     * @memberof Calendar
     */
    'id'?: number;
}
/**
 * 
 * @export
 * @interface CalendarAccount
 */
export interface CalendarAccount {
    /**
     * 
     * @type {string}
     * @memberof CalendarAccount
     */
    'provider'?: string;
    /**
     * 
     * @type {string}
     * @memberof CalendarAccount
     */
    'accountEmail'?: string;
    /**
     * 
     * @type {string}
     * @memberof CalendarAccount
     */
    'syncState'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CalendarAccount
     */
    'hasOptedInTo2WaySync'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof CalendarAccount
     */
    'id'?: number;
}
/**
 * 
 * @export
 * @interface CalendarInfoResponse
 */
export interface CalendarInfoResponse {
    /**
     * 
     * @type {Array<Calendar>}
     * @memberof CalendarInfoResponse
     */
    'calendars'?: Array<Calendar>;
    /**
     * 
     * @type {Array<CalendarAccount>}
     * @memberof CalendarInfoResponse
     */
    'calendarAccounts'?: Array<CalendarAccount>;
    /**
     * 
     * @type {number}
     * @memberof CalendarInfoResponse
     */
    'defaultCalendarID'?: number;
}
/**
 * 
 * @export
 * @interface ChangePartialCompleteStatusResponse
 */
export interface ChangePartialCompleteStatusResponse {
    /**
     * 
     * @type {boolean}
     * @memberof ChangePartialCompleteStatusResponse
     */
    'wholeTaskCompleted'?: boolean;
    /**
     * 
     * @type {{ [key: string]: ItemShiftInfoMapValue; }}
     * @memberof ChangePartialCompleteStatusResponse
     */
    'itemShiftInfoMap'?: { [key: string]: ItemShiftInfoMapValue; };
    /**
     * 
     * @type {DifferentVersions}
     * @memberof ChangePartialCompleteStatusResponse
     */
    'differentVersions'?: DifferentVersions;
    /**
     * 
     * @type {ScheduleItemDiff}
     * @memberof ChangePartialCompleteStatusResponse
     */
    'scheduleItemDiff'?: ScheduleItemDiff;
}
/**
 * 
 * @export
 * @interface DifferentVersions
 */
export interface DifferentVersions {
    [key: string]: string | any;

    /**
     * 
     * @type {string}
     * @memberof DifferentVersions
     */
    'Items'?: string;
    /**
     * 
     * @type {string}
     * @memberof DifferentVersions
     */
    'Calendars'?: string;
    /**
     * 
     * @type {string}
     * @memberof DifferentVersions
     */
    'Subscription'?: string;
}
/**
 * 
 * @export
 * @interface FeatureFlagOverrideInfo
 */
export interface FeatureFlagOverrideInfo {
    /**
     * 
     * @type {string}
     * @memberof FeatureFlagOverrideInfo
     */
    'aesthetic'?: string;
}
/**
 * 
 * @export
 * @interface GetScheduleResponse
 */
export interface GetScheduleResponse {
    /**
     * 
     * @type {ScheduleResponseData}
     * @memberof GetScheduleResponse
     */
    'scheduleResponse'?: ScheduleResponseData;
}
/**
 * 
 * @export
 * @interface GetToDoListContentResponse
 */
export interface GetToDoListContentResponse {
    /**
     * 
     * @type {ToDoListResponseData}
     * @memberof GetToDoListContentResponse
     */
    'toDoListResponse'?: ToDoListResponseData;
}
/**
 * 
 * @export
 * @interface GetUpdatesResponse
 */
export interface GetUpdatesResponse {
    /**
     * 
     * @type {SyncInfo}
     * @memberof GetUpdatesResponse
     */
    'syncInfo'?: SyncInfo;
    /**
     * 
     * @type {DifferentVersions}
     * @memberof GetUpdatesResponse
     */
    'differentVersions'?: DifferentVersions;
}
/**
 * 
 * @export
 * @interface InboxItem
 */
export interface InboxItem {
    /**
     * 
     * @type {number}
     * @memberof InboxItem
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof InboxItem
     */
    'Title': string;
}
/**
 * 
 * @export
 * @interface InboxItemsResponse
 */
export interface InboxItemsResponse {
    /**
     * 
     * @type {Array<InboxItem>}
     * @memberof InboxItemsResponse
     */
    'items'?: Array<InboxItem>;
}
/**
 * 
 * @export
 * @interface InitialDataResponse
 */
export interface InitialDataResponse {
    /**
     * 
     * @type {Array<CalendarAccount>}
     * @memberof InitialDataResponse
     */
    'calendarAccounts'?: Array<CalendarAccount>;
    /**
     * 
     * @type {Array<Calendar>}
     * @memberof InitialDataResponse
     */
    'calendars'?: Array<Calendar>;
    /**
     * 
     * @type {number}
     * @memberof InitialDataResponse
     */
    'defaultCalendarID'?: number;
    /**
     * 
     * @type {UserSettings}
     * @memberof InitialDataResponse
     */
    'userSettings'?: UserSettings;
    /**
     * 
     * @type {number}
     * @memberof InitialDataResponse
     */
    'clientToAppOffsetMilliseconds'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof InitialDataResponse
     */
    'colors'?: Array<string>;
    /**
     * 
     * @type {DifferentVersions}
     * @memberof InitialDataResponse
     */
    'differentVersions'?: DifferentVersions;
    /**
     * 
     * @type {Subscription}
     * @memberof InitialDataResponse
     */
    'subscription'?: Subscription;
    /**
     * 
     * @type {OnboardingInfo}
     * @memberof InitialDataResponse
     */
    'onboardingInfo'?: OnboardingInfo;
    /**
     * 
     * @type {number}
     * @memberof InitialDataResponse
     */
    'defaultTimeProfileId'?: number;
    /**
     * 
     * @type {Array<TimeProfile>}
     * @memberof InitialDataResponse
     */
    'timeProfiles'?: Array<TimeProfile>;
    /**
     * 
     * @type {User}
     * @memberof InitialDataResponse
     */
    'user'?: User;
    /**
     * 
     * @type {ItemSettings}
     * @memberof InitialDataResponse
     */
    'itemSettings'?: ItemSettings;
    /**
     * 
     * @type {FeatureFlagOverrideInfo}
     * @memberof InitialDataResponse
     */
    'featureFlagOverrideInfo'?: FeatureFlagOverrideInfo;
}
/**
 * 
 * @export
 * @interface IsAuthenticatedResponse
 */
export interface IsAuthenticatedResponse {
    /**
     * 
     * @type {boolean}
     * @memberof IsAuthenticatedResponse
     */
    'isAuthenticated'?: boolean;
}
/**
 * 
 * @export
 * @interface ItemCore
 */
export interface ItemCore {
    /**
     * Item ID. 0 for new items.
     * @type {number}
     * @memberof ItemCore
     */
    'id'?: number;
    /**
     * Instance ID of the item, if applicable.
     * @type {number}
     * @memberof ItemCore
     */
    'InstanceID'?: number;
    /**
     * Notes for the item.
     * @type {string}
     * @memberof ItemCore
     */
    'Notes'?: string;
    /**
     * Due date and time for the item.
     * @type {string}
     * @memberof ItemCore
     */
    'DueDateTime'?: string | null;
    /**
     * Start date and time for the item.
     * @type {string}
     * @memberof ItemCore
     */
    'StartDateTime'?: string;
    /**
     * End date and time for the item.
     * @type {string}
     * @memberof ItemCore
     */
    'EndDateTime'?: string;
    /**
     * Do not start until this date and time.
     * @type {string}
     * @memberof ItemCore
     */
    'DontStartUntil'?: string;
    /**
     * Timezone for the item.
     * @type {string}
     * @memberof ItemCore
     */
    'TimeZone'?: string;
    /**
     * Whether the item is auto-ignored.
     * @type {boolean}
     * @memberof ItemCore
     */
    'IsAutoIgnored'?: boolean;
    /**
     * Title of the item.
     * @type {string}
     * @memberof ItemCore
     */
    'Title'?: string;
    /**
     * Type of the item (e.g., task, event).
     * @type {string}
     * @memberof ItemCore
     */
    'ItemType'?: string;
    /**
     * Progress in hours.
     * @type {number}
     * @memberof ItemCore
     */
    'ProgressHours'?: number;
    /**
     * Progress in minutes.
     * @type {number}
     * @memberof ItemCore
     */
    'ProgressMinutes'?: number;
    /**
     * Minimum length of the item in total minutes.
     * @type {number}
     * @memberof ItemCore
     */
    'minLengthTotalMinutes'?: number;
    /**
     * 
     * @type {number}
     * @memberof ItemCore
     */
    'BufferTimeBeforeHours'?: number;
    /**
     * 
     * @type {number}
     * @memberof ItemCore
     */
    'BufferTimeBeforeMinutes'?: number;
    /**
     * 
     * @type {number}
     * @memberof ItemCore
     */
    'BufferTimeAfterHours'?: number;
    /**
     * 
     * @type {number}
     * @memberof ItemCore
     */
    'BufferTimeAfterMinutes'?: number;
    /**
     * Whether the item marks time as busy.
     * @type {boolean}
     * @memberof ItemCore
     */
    'Busy'?: boolean;
    /**
     * Whether the item has a fixed time.
     * @type {boolean}
     * @memberof ItemCore
     */
    'FixedTime'?: boolean;
    /**
     * Whether the item is an all-day event.
     * @type {boolean}
     * @memberof ItemCore
     */
    'AllDay'?: boolean;
    /**
     * Repeat type (e.g., Never, Daily, Weekly, Yearly).
     * @type {string}
     * @memberof ItemCore
     */
    'RepeatType'?: string;
    /**
     * 
     * @type {number}
     * @memberof ItemCore
     */
    'Interval'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ItemCore
     */
    'Sunday'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ItemCore
     */
    'Monday'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ItemCore
     */
    'Tuesday'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ItemCore
     */
    'Wednesday'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ItemCore
     */
    'Thursday'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ItemCore
     */
    'Friday'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ItemCore
     */
    'Saturday'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ItemCore
     */
    'MonthlyType'?: string;
    /**
     * 
     * @type {string}
     * @memberof ItemCore
     */
    'Dates'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ItemCore
     */
    'MonthOrdinal'?: number;
    /**
     * 
     * @type {number}
     * @memberof ItemCore
     */
    'WeekDay'?: number;
    /**
     * 
     * @type {string}
     * @memberof ItemCore
     */
    'EndRepeatType'?: string;
    /**
     * 
     * @type {string}
     * @memberof ItemCore
     */
    'EndRepeatDate'?: string;
    /**
     * 
     * @type {number}
     * @memberof ItemCore
     */
    'NumOccurrences'?: number;
    /**
     * Priority of the item.
     * @type {number}
     * @memberof ItemCore
     */
    'priority'?: number;
    /**
     * Custom color for the item (hex code).
     * @type {string}
     * @memberof ItemCore
     */
    'customColor'?: string | null;
    /**
     * ID of the calendar this item belongs to.
     * @type {number}
     * @memberof ItemCore
     */
    'calendarId'?: number;
    /**
     * ID of the time profile associated with this item.
     * @type {number}
     * @memberof ItemCore
     */
    'timeProfileId'?: number | null;
    /**
     * Comma-separated string of tag IDs for create/update.
     * @type {string}
     * @memberof ItemCore
     */
    'tagIds'?: string;
    /**
     * 
     * @type {string}
     * @memberof ItemCore
     */
    'Location'?: string | null;
}
/**
 * 
 * @export
 * @interface ItemCreateResponse
 */
export interface ItemCreateResponse {
    /**
     * 
     * @type {number}
     * @memberof ItemCreateResponse
     */
    'newItemId'?: number;
    /**
     * 
     * @type {number}
     * @memberof ItemCreateResponse
     */
    'numRepeatingAutoScheduledTasks'?: number | null;
    /**
     * 
     * @type {DifferentVersions}
     * @memberof ItemCreateResponse
     */
    'differentVersions'?: DifferentVersions;
    /**
     * 
     * @type {number}
     * @memberof ItemCreateResponse
     */
    'numAutoScheduledTasksAdded'?: number | null;
}
/**
 * 
 * @export
 * @interface ItemEditGetDataResponse
 */
export interface ItemEditGetDataResponse {
    /**
     * 
     * @type {ItemFull}
     * @memberof ItemEditGetDataResponse
     */
    'item'?: ItemFull;
    /**
     * 
     * @type {SchedulingStatusInfo}
     * @memberof ItemEditGetDataResponse
     */
    'schedulingStatusInfo'?: SchedulingStatusInfo;
    /**
     * 
     * @type {Array<ScheduleItemData>}
     * @memberof ItemEditGetDataResponse
     */
    'scheduleItems'?: Array<ScheduleItemData>;
    /**
     * 
     * @type {Array<number>}
     * @memberof ItemEditGetDataResponse
     */
    'repeatingAutoScheduledTaskIds'?: Array<number> | null;
}
/**
 * 
 * @export
 * @interface ItemEditResponse
 */
export interface ItemEditResponse {
    /**
     * 
     * @type {number}
     * @memberof ItemEditResponse
     */
    'numRepeatingAutoScheduledTasks'?: number | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ItemEditResponse
     */
    'itemShiftInfoMap'?: { [key: string]: any; };
    /**
     * 
     * @type {DifferentVersions}
     * @memberof ItemEditResponse
     */
    'differentVersions'?: DifferentVersions;
    /**
     * 
     * @type {ScheduleItemDiff}
     * @memberof ItemEditResponse
     */
    'scheduleItemDiff'?: ScheduleItemDiff;
}
/**
 * 
 * @export
 * @interface ItemFull
 */
export interface ItemFull {
    /**
     * Array of tag IDs for display.
     * @type {Array<number>}
     * @memberof ItemFull
     */
    'tagIds'?: Array<number>;
    /**
     * 
     * @type {boolean}
     * @memberof ItemFull
     */
    'Completed'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ItemFull
     */
    'AccessLevel'?: number;
    /**
     * Resolved color of the item (e.g., \"red\", \"green\").
     * @type {string}
     * @memberof ItemFull
     */
    'Color'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ItemFull
     */
    'Changed'?: boolean;
    /**
     * 
     * @type {Array<object>}
     * @memberof ItemFull
     */
    'upstreamItemInfos'?: Array<object>;
    /**
     * 
     * @type {Array<object>}
     * @memberof ItemFull
     */
    'downstreamItemInfos'?: Array<object>;
    /**
     * 
     * @type {string}
     * @memberof ItemFull
     */
    'SortTime'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ItemFull
     */
    'ParentItemID'?: number | null;
    /**
     * 
     * @type {object}
     * @memberof ItemFull
     */
    'ParentItem'?: object | null;
    /**
     * 
     * @type {string}
     * @memberof ItemFull
     */
    'LastMovedUtc'?: string;
    /**
     * Item ID. 0 for new items.
     * @type {number}
     * @memberof ItemFull
     */
    'id'?: number;
    /**
     * Instance ID of the item, if applicable.
     * @type {number}
     * @memberof ItemFull
     */
    'InstanceID'?: number;
    /**
     * Notes for the item.
     * @type {string}
     * @memberof ItemFull
     */
    'Notes'?: string;
    /**
     * Due date and time for the item.
     * @type {string}
     * @memberof ItemFull
     */
    'DueDateTime'?: string | null;
    /**
     * Start date and time for the item.
     * @type {string}
     * @memberof ItemFull
     */
    'StartDateTime'?: string;
    /**
     * End date and time for the item.
     * @type {string}
     * @memberof ItemFull
     */
    'EndDateTime'?: string;
    /**
     * Do not start until this date and time.
     * @type {string}
     * @memberof ItemFull
     */
    'DontStartUntil'?: string;
    /**
     * Timezone for the item.
     * @type {string}
     * @memberof ItemFull
     */
    'TimeZone'?: string;
    /**
     * Whether the item is auto-ignored.
     * @type {boolean}
     * @memberof ItemFull
     */
    'IsAutoIgnored'?: boolean;
    /**
     * Title of the item.
     * @type {string}
     * @memberof ItemFull
     */
    'Title'?: string;
    /**
     * Type of the item (e.g., task, event).
     * @type {string}
     * @memberof ItemFull
     */
    'ItemType'?: string;
    /**
     * Progress in hours.
     * @type {number}
     * @memberof ItemFull
     */
    'ProgressHours'?: number;
    /**
     * Progress in minutes.
     * @type {number}
     * @memberof ItemFull
     */
    'ProgressMinutes'?: number;
    /**
     * Minimum length of the item in total minutes.
     * @type {number}
     * @memberof ItemFull
     */
    'minLengthTotalMinutes'?: number;
    /**
     * 
     * @type {number}
     * @memberof ItemFull
     */
    'BufferTimeBeforeHours'?: number;
    /**
     * 
     * @type {number}
     * @memberof ItemFull
     */
    'BufferTimeBeforeMinutes'?: number;
    /**
     * 
     * @type {number}
     * @memberof ItemFull
     */
    'BufferTimeAfterHours'?: number;
    /**
     * 
     * @type {number}
     * @memberof ItemFull
     */
    'BufferTimeAfterMinutes'?: number;
    /**
     * Whether the item marks time as busy.
     * @type {boolean}
     * @memberof ItemFull
     */
    'Busy'?: boolean;
    /**
     * Whether the item has a fixed time.
     * @type {boolean}
     * @memberof ItemFull
     */
    'FixedTime'?: boolean;
    /**
     * Whether the item is an all-day event.
     * @type {boolean}
     * @memberof ItemFull
     */
    'AllDay'?: boolean;
    /**
     * Repeat type (e.g., Never, Daily, Weekly, Yearly).
     * @type {string}
     * @memberof ItemFull
     */
    'RepeatType'?: string;
    /**
     * 
     * @type {number}
     * @memberof ItemFull
     */
    'Interval'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ItemFull
     */
    'Sunday'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ItemFull
     */
    'Monday'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ItemFull
     */
    'Tuesday'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ItemFull
     */
    'Wednesday'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ItemFull
     */
    'Thursday'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ItemFull
     */
    'Friday'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ItemFull
     */
    'Saturday'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ItemFull
     */
    'MonthlyType'?: string;
    /**
     * 
     * @type {string}
     * @memberof ItemFull
     */
    'Dates'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ItemFull
     */
    'MonthOrdinal'?: number;
    /**
     * 
     * @type {number}
     * @memberof ItemFull
     */
    'WeekDay'?: number;
    /**
     * 
     * @type {string}
     * @memberof ItemFull
     */
    'EndRepeatType'?: string;
    /**
     * 
     * @type {string}
     * @memberof ItemFull
     */
    'EndRepeatDate'?: string;
    /**
     * 
     * @type {number}
     * @memberof ItemFull
     */
    'NumOccurrences'?: number;
    /**
     * Priority of the item.
     * @type {number}
     * @memberof ItemFull
     */
    'priority'?: number;
    /**
     * Custom color for the item (hex code).
     * @type {string}
     * @memberof ItemFull
     */
    'customColor'?: string | null;
    /**
     * ID of the calendar this item belongs to.
     * @type {number}
     * @memberof ItemFull
     */
    'calendarId'?: number;
    /**
     * ID of the time profile associated with this item.
     * @type {number}
     * @memberof ItemFull
     */
    'timeProfileId'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ItemFull
     */
    'Location'?: string | null;
}
/**
 * 
 * @export
 * @interface ItemSettings
 */
export interface ItemSettings {
    /**
     * 
     * @type {boolean}
     * @memberof ItemSettings
     */
    'moreOptionsExpanded'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ItemSettings
     */
    'splittable'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ItemSettings
     */
    'minLengthTotalMinutes'?: number;
    /**
     * 
     * @type {number}
     * @memberof ItemSettings
     */
    'bufferTimeBeforeHours'?: number;
    /**
     * 
     * @type {number}
     * @memberof ItemSettings
     */
    'bufferTimeBeforeMinutes'?: number;
    /**
     * 
     * @type {number}
     * @memberof ItemSettings
     */
    'bufferTimeAfterHours'?: number;
    /**
     * 
     * @type {number}
     * @memberof ItemSettings
     */
    'bufferTimeAfterMinutes'?: number;
    /**
     * 
     * @type {number}
     * @memberof ItemSettings
     */
    'durationTotalMinutes'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ItemSettings
     */
    'useSmartColorCoding'?: boolean;
}
/**
 * 
 * @export
 * @interface ItemShiftInfoMapValue
 */
export interface ItemShiftInfoMapValue {
    /**
     * 
     * @type {{ [key: string]: ItemFull; }}
     * @memberof ItemShiftInfoMapValue
     */
    'oldInstanceIdsToNewItems'?: { [key: string]: ItemFull; };
    /**
     * 
     * @type {object}
     * @memberof ItemShiftInfoMapValue
     */
    'instanceIdShiftInfo'?: object | null;
}
/**
 * 
 * @export
 * @interface LoginSuccessResponse
 */
export interface LoginSuccessResponse {
    /**
     * 
     * @type {string}
     * @memberof LoginSuccessResponse
     */
    'message'?: string;
}
/**
 * Represents a schedule item that has been modified, often returned in diffs.
 * @export
 * @interface ModifiedScheduleItem
 */
export interface ModifiedScheduleItem {
    /**
     * Often 0 if the primary ID is within the nested Item object.
     * @type {number}
     * @memberof ModifiedScheduleItem
     */
    'ItemID'?: number;
    /**
     * 
     * @type {ItemFull}
     * @memberof ModifiedScheduleItem
     */
    'Item'?: ItemFull;
    /**
     * 
     * @type {number}
     * @memberof ModifiedScheduleItem
     */
    'InstanceID'?: number;
    /**
     * 
     * @type {string}
     * @memberof ModifiedScheduleItem
     */
    'StartTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModifiedScheduleItem
     */
    'EndTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModifiedScheduleItem
     */
    'Color'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ModifiedScheduleItem
     */
    'ThisPartCompleted'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ModifiedScheduleItem
     */
    'InstanceStartDateTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModifiedScheduleItem
     */
    'InstanceEndDateTime'?: string;
    /**
     * The ID of this specific schedule item instance/part.
     * @type {number}
     * @memberof ModifiedScheduleItem
     */
    'id'?: number;
}
/**
 * 
 * @export
 * @interface MultipleDeleteResponse
 */
export interface MultipleDeleteResponse {
    /**
     * 
     * @type {DifferentVersions}
     * @memberof MultipleDeleteResponse
     */
    'differentVersions'?: DifferentVersions;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof MultipleDeleteResponse
     */
    'itemShiftInfoMap'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface OnboardingInfo
 */
export interface OnboardingInfo {
    /**
     * 
     * @type {string}
     * @memberof OnboardingInfo
     */
    'onboardingStage'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof OnboardingInfo
     */
    'numAutoScheduledTasksAdded'?: number | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof OnboardingInfo
     */
    'completedSteps'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface RecalculateResponse
 */
export interface RecalculateResponse {
    /**
     * 
     * @type {RecalculateResponseDisplayDTOs}
     * @memberof RecalculateResponse
     */
    'displayDTOs'?: RecalculateResponseDisplayDTOs;
    /**
     * 
     * @type {SyncInfo}
     * @memberof RecalculateResponse
     */
    'syncInfo'?: SyncInfo;
    /**
     * 
     * @type {DifferentVersions}
     * @memberof RecalculateResponse
     */
    'differentVersions'?: DifferentVersions;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof RecalculateResponse
     */
    'itemShiftInfoMap'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface RecalculateResponseDisplayDTOs
 */
export interface RecalculateResponseDisplayDTOs {
    /**
     * 
     * @type {ScheduleResponseData}
     * @memberof RecalculateResponseDisplayDTOs
     */
    'scheduleResponse'?: ScheduleResponseData;
    /**
     * 
     * @type {ToDoListResponseData}
     * @memberof RecalculateResponseDisplayDTOs
     */
    'toDoListResponse'?: ToDoListResponseData;
}
/**
 * 
 * @export
 * @interface ScheduleItem
 */
export interface ScheduleItem {
    /**
     * 
     * @type {number}
     * @memberof ScheduleItem
     */
    'ItemID'?: number;
    /**
     * 
     * @type {ItemFull}
     * @memberof ScheduleItem
     */
    'Item'?: ItemFull;
    /**
     * 
     * @type {number}
     * @memberof ScheduleItem
     */
    'InstanceID'?: number;
    /**
     * 
     * @type {string}
     * @memberof ScheduleItem
     */
    'StartTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof ScheduleItem
     */
    'EndTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof ScheduleItem
     */
    'Color'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ScheduleItem
     */
    'ThisPartCompleted'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ScheduleItem
     */
    'InstanceStartDateTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof ScheduleItem
     */
    'InstanceEndDateTime'?: string;
    /**
     * 
     * @type {number}
     * @memberof ScheduleItem
     */
    'id'?: number;
}
/**
 * 
 * @export
 * @interface ScheduleItemData
 */
export interface ScheduleItemData {
    /**
     * 
     * @type {number}
     * @memberof ScheduleItemData
     */
    'ItemID'?: number;
    /**
     * 
     * @type {object}
     * @memberof ScheduleItemData
     */
    'Item'?: object | null;
    /**
     * 
     * @type {number}
     * @memberof ScheduleItemData
     */
    'InstanceID'?: number;
    /**
     * 
     * @type {string}
     * @memberof ScheduleItemData
     */
    'StartTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof ScheduleItemData
     */
    'EndTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof ScheduleItemData
     */
    'Color'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ScheduleItemData
     */
    'ThisPartCompleted'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ScheduleItemData
     */
    'InstanceStartDateTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof ScheduleItemData
     */
    'InstanceEndDateTime'?: string;
    /**
     * 
     * @type {number}
     * @memberof ScheduleItemData
     */
    'id'?: number;
}
/**
 * 
 * @export
 * @interface ScheduleItemDiff
 */
export interface ScheduleItemDiff {
    /**
     * 
     * @type {Array<number>}
     * @memberof ScheduleItemDiff
     */
    'deletedScheduleItemIds'?: Array<number>;
    /**
     * 
     * @type {Array<ModifiedScheduleItem>}
     * @memberof ScheduleItemDiff
     */
    'newOrModifiedScheduleItems'?: Array<ModifiedScheduleItem>;
    /**
     * 
     * @type {Array<number>}
     * @memberof ScheduleItemDiff
     */
    'deletedItemIds'?: Array<number>;
}
/**
 * 
 * @export
 * @interface ScheduleResponseData
 */
export interface ScheduleResponseData {
    /**
     * 
     * @type {string}
     * @memberof ScheduleResponseData
     */
    'startDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof ScheduleResponseData
     */
    'horizon'?: string;
    /**
     * 
     * @type {Array<ScheduleItem>}
     * @memberof ScheduleResponseData
     */
    'scheduleItems'?: Array<ScheduleItem>;
    /**
     * 
     * @type {Array<AllDayEvent>}
     * @memberof ScheduleResponseData
     */
    'allDayEvents'?: Array<AllDayEvent>;
}
/**
 * 
 * @export
 * @interface SchedulingStatusInfo
 */
export interface SchedulingStatusInfo {
    /**
     * 
     * @type {number}
     * @memberof SchedulingStatusInfo
     */
    'bufferDays'?: number;
    /**
     * 
     * @type {string}
     * @memberof SchedulingStatusInfo
     */
    'missedDependencyTitle'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof SchedulingStatusInfo
     */
    'specialSchedulingCase'?: number;
}
/**
 * 
 * @export
 * @interface SearchResponseData
 */
export interface SearchResponseData {
    /**
     * 
     * @type {Array<ItemFull>}
     * @memberof SearchResponseData
     */
    'items'?: Array<ItemFull>;
    /**
     * 
     * @type {boolean}
     * @memberof SearchResponseData
     */
    'oldCompletedTasksHidden'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SearchResponseData
     */
    'hasNextPage'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SearchResponseData
     */
    'hasPreviousPage'?: boolean;
    /**
     * 
     * @type {Array<number>}
     * @memberof SearchResponseData
     */
    'repeatingAutoScheduledTaskIds'?: Array<number> | null;
    /**
     * 
     * @type {{ [key: string]: boolean; }}
     * @memberof SearchResponseData
     */
    'tasksMissingDeadlines'?: { [key: string]: boolean; } | null;
}
/**
 * 
 * @export
 * @interface SearchResponseWrapper
 */
export interface SearchResponseWrapper {
    /**
     * 
     * @type {SearchResponseData}
     * @memberof SearchResponseWrapper
     */
    'searchResponse'?: SearchResponseData;
}
/**
 * 
 * @export
 * @interface Subscription
 */
export interface Subscription {
    /**
     * 
     * @type {boolean}
     * @memberof Subscription
     */
    'hasClaimedFreeTrial'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Subscription
     */
    'isLifetime'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Subscription
     */
    'isPro'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    'store'?: string;
    /**
     * 
     * @type {string}
     * @memberof Subscription
     */
    'expiresUtc'?: string;
}
/**
 * 
 * @export
 * @interface SyncInfo
 */
export interface SyncInfo {
    /**
     * 
     * @type {string}
     * @memberof SyncInfo
     */
    'syncState'?: string;
    /**
     * 
     * @type {string}
     * @memberof SyncInfo
     */
    'lastSyncedInAppTime'?: string | null;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof SyncInfo
     */
    'calendarAccountSyncStates'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface Tag
 */
export interface Tag {
    /**
     * 
     * @type {number}
     * @memberof Tag
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    'color'?: string;
}
/**
 * 
 * @export
 * @interface TagListResponse
 */
export interface TagListResponse {
    /**
     * 
     * @type {Array<Tag>}
     * @memberof TagListResponse
     */
    'tags'?: Array<Tag>;
}
/**
 * 
 * @export
 * @interface TaskItem
 */
export interface TaskItem {
    /**
     * Comma-separated string of tag IDs for create/update.
     * @type {string}
     * @memberof TaskItem
     */
    'tagIds'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TaskItem
     */
    'Completed'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof TaskItem
     */
    'AccessLevel'?: number;
    /**
     * Resolved color of the item (e.g., \"red\", \"green\").
     * @type {string}
     * @memberof TaskItem
     */
    'Color'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof TaskItem
     */
    'Changed'?: boolean;
    /**
     * 
     * @type {Array<object>}
     * @memberof TaskItem
     */
    'upstreamItemInfos'?: Array<object>;
    /**
     * 
     * @type {Array<object>}
     * @memberof TaskItem
     */
    'downstreamItemInfos'?: Array<object>;
    /**
     * 
     * @type {string}
     * @memberof TaskItem
     */
    'SortTime'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof TaskItem
     */
    'ParentItemID'?: number | null;
    /**
     * 
     * @type {object}
     * @memberof TaskItem
     */
    'ParentItem'?: object | null;
    /**
     * 
     * @type {string}
     * @memberof TaskItem
     */
    'LastMovedUtc'?: string;
    /**
     * Item ID. 0 for new items.
     * @type {number}
     * @memberof TaskItem
     */
    'id'?: number;
    /**
     * Instance ID of the item, if applicable.
     * @type {number}
     * @memberof TaskItem
     */
    'InstanceID'?: number;
    /**
     * Notes for the item.
     * @type {string}
     * @memberof TaskItem
     */
    'Notes'?: string;
    /**
     * Due date and time for the item.
     * @type {string}
     * @memberof TaskItem
     */
    'DueDateTime'?: string | null;
    /**
     * Start date and time for the item.
     * @type {string}
     * @memberof TaskItem
     */
    'StartDateTime'?: string;
    /**
     * End date and time for the item.
     * @type {string}
     * @memberof TaskItem
     */
    'EndDateTime'?: string;
    /**
     * Do not start until this date and time.
     * @type {string}
     * @memberof TaskItem
     */
    'DontStartUntil'?: string;
    /**
     * Timezone for the item.
     * @type {string}
     * @memberof TaskItem
     */
    'TimeZone'?: string;
    /**
     * Whether the item is auto-ignored.
     * @type {boolean}
     * @memberof TaskItem
     */
    'IsAutoIgnored'?: boolean;
    /**
     * Title of the item.
     * @type {string}
     * @memberof TaskItem
     */
    'Title'?: string;
    /**
     * Type of the item (e.g., task, event).
     * @type {string}
     * @memberof TaskItem
     */
    'ItemType'?: string;
    /**
     * Progress in hours.
     * @type {number}
     * @memberof TaskItem
     */
    'ProgressHours'?: number;
    /**
     * Progress in minutes.
     * @type {number}
     * @memberof TaskItem
     */
    'ProgressMinutes'?: number;
    /**
     * Minimum length of the item in total minutes.
     * @type {number}
     * @memberof TaskItem
     */
    'minLengthTotalMinutes'?: number;
    /**
     * 
     * @type {number}
     * @memberof TaskItem
     */
    'BufferTimeBeforeHours'?: number;
    /**
     * 
     * @type {number}
     * @memberof TaskItem
     */
    'BufferTimeBeforeMinutes'?: number;
    /**
     * 
     * @type {number}
     * @memberof TaskItem
     */
    'BufferTimeAfterHours'?: number;
    /**
     * 
     * @type {number}
     * @memberof TaskItem
     */
    'BufferTimeAfterMinutes'?: number;
    /**
     * Whether the item marks time as busy.
     * @type {boolean}
     * @memberof TaskItem
     */
    'Busy'?: boolean;
    /**
     * Whether the item has a fixed time.
     * @type {boolean}
     * @memberof TaskItem
     */
    'FixedTime'?: boolean;
    /**
     * Whether the item is an all-day event.
     * @type {boolean}
     * @memberof TaskItem
     */
    'AllDay'?: boolean;
    /**
     * Repeat type (e.g., Never, Daily, Weekly, Yearly).
     * @type {string}
     * @memberof TaskItem
     */
    'RepeatType'?: string;
    /**
     * 
     * @type {number}
     * @memberof TaskItem
     */
    'Interval'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof TaskItem
     */
    'Sunday'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TaskItem
     */
    'Monday'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TaskItem
     */
    'Tuesday'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TaskItem
     */
    'Wednesday'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TaskItem
     */
    'Thursday'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TaskItem
     */
    'Friday'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof TaskItem
     */
    'Saturday'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof TaskItem
     */
    'MonthlyType'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskItem
     */
    'Dates'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof TaskItem
     */
    'MonthOrdinal'?: number;
    /**
     * 
     * @type {number}
     * @memberof TaskItem
     */
    'WeekDay'?: number;
    /**
     * 
     * @type {string}
     * @memberof TaskItem
     */
    'EndRepeatType'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaskItem
     */
    'EndRepeatDate'?: string;
    /**
     * 
     * @type {number}
     * @memberof TaskItem
     */
    'NumOccurrences'?: number;
    /**
     * Priority of the item.
     * @type {number}
     * @memberof TaskItem
     */
    'priority'?: number;
    /**
     * Custom color for the item (hex code).
     * @type {string}
     * @memberof TaskItem
     */
    'customColor'?: string | null;
    /**
     * ID of the calendar this item belongs to.
     * @type {number}
     * @memberof TaskItem
     */
    'calendarId'?: number;
    /**
     * ID of the time profile associated with this item.
     * @type {number}
     * @memberof TaskItem
     */
    'timeProfileId'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof TaskItem
     */
    'Location'?: string | null;
}
/**
 * 
 * @export
 * @interface TimeProfile
 */
export interface TimeProfile {
    /**
     * 
     * @type {number}
     * @memberof TimeProfile
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof TimeProfile
     */
    'Title'?: string;
}
/**
 * 
 * @export
 * @interface ToDoListResponseData
 */
export interface ToDoListResponseData {
    /**
     * 
     * @type {Array<TaskItem>}
     * @memberof ToDoListResponseData
     */
    'tasks'?: Array<TaskItem>;
    /**
     * 
     * @type {boolean}
     * @memberof ToDoListResponseData
     */
    'oldCompletedTasksHidden'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ToDoListResponseData
     */
    'hasNextPage'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ToDoListResponseData
     */
    'hasPreviousPage'?: boolean;
    /**
     * 
     * @type {Array<number>}
     * @memberof ToDoListResponseData
     */
    'repeatingAutoScheduledTaskIds'?: Array<number> | null;
    /**
     * 
     * @type {{ [key: string]: boolean; }}
     * @memberof ToDoListResponseData
     */
    'tasksMissingDeadlines'?: { [key: string]: boolean; };
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'identityUserId'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'userHash'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'isEmailConfirmed'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'dateCreatedUtc'?: string;
    /**
     * 
     * @type {UserActionHistory}
     * @memberof User
     */
    'actionHistory'?: UserActionHistory;
}
/**
 * 
 * @export
 * @interface UserActionHistory
 */
export interface UserActionHistory {
    /**
     * 
     * @type {boolean}
     * @memberof UserActionHistory
     */
    'HasDismissedReorderHint'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserActionHistory
     */
    'HasDismissedCopySchedulingHoursTip'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserActionHistory
     */
    'HasDismissedAestheticHardUpdate'?: boolean;
}
/**
 * 
 * @export
 * @interface UserSettings
 */
export interface UserSettings {
    /**
     * 
     * @type {boolean}
     * @memberof UserSettings
     */
    'autoRecalculate'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserSettings
     */
    'workloadDistribution'?: string;
    /**
     * 
     * @type {number}
     * @memberof UserSettings
     */
    'bufferDays'?: number;
    /**
     * 
     * @type {number}
     * @memberof UserSettings
     */
    'weeksAhead'?: number;
    /**
     * 
     * @type {number}
     * @memberof UserSettings
     */
    'weekStartType'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof UserSettings
     */
    'use24HourTime'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserSettings
     */
    'showCompletedTasks'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserSettings
     */
    'timeZoneDefault'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserSettings
     */
    'timeZone'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserSettings
     */
    'detectTimeZoneChanges'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserSettings
     */
    'theme'?: string;
}

/**
 * AccountApi - axios parameter creator
 * @export
 */
export const AccountApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Logs in a user
         * @param {string} Email User\\\&#39;s email address.
         * @param {string} Password User\\\&#39;s password.
         * @param {string} [clientTimeZone] Client\\\&#39;s timezone.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountLoginPost: async (Email: string, Password: string, clientTimeZone?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'Email' is not null or undefined
            assertParamExists('apiAccountLoginPost', 'Email', Email)
            // verify required parameter 'Password' is not null or undefined
            assertParamExists('apiAccountLoginPost', 'Password', Password)
            const localVarPath = `/api/Account/Login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication csrfTokenHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-csrf-token", configuration)

            // authentication cookieAuthAntiforgery required

            // authentication cookieAuthIdentity required


            if (Email !== undefined) { 
                localVarFormParams.append('Email', Email as any);
            }
    
            if (Password !== undefined) { 
                localVarFormParams.append('Password', Password as any);
            }
    
            if (clientTimeZone !== undefined) { 
                localVarFormParams.append('clientTimeZone', clientTimeZone as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountApi - functional programming interface
 * @export
 */
export const AccountApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Logs in a user
         * @param {string} Email User\\\&#39;s email address.
         * @param {string} Password User\\\&#39;s password.
         * @param {string} [clientTimeZone] Client\\\&#39;s timezone.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAccountLoginPost(Email: string, Password: string, clientTimeZone?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiAccountLoginPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAccountLoginPost(Email, Password, clientTimeZone, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountApi.apiAccountLoginPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AccountApi - factory interface
 * @export
 */
export const AccountApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountApiFp(configuration)
    return {
        /**
         * 
         * @summary Logs in a user
         * @param {AccountApiApiAccountLoginPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccountLoginPost(requestParameters: AccountApiApiAccountLoginPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ApiAccountLoginPost200Response> {
            return localVarFp.apiAccountLoginPost(requestParameters.Email, requestParameters.Password, requestParameters.clientTimeZone, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for apiAccountLoginPost operation in AccountApi.
 * @export
 * @interface AccountApiApiAccountLoginPostRequest
 */
export interface AccountApiApiAccountLoginPostRequest {
    /**
     * User\\\&#39;s email address.
     * @type {string}
     * @memberof AccountApiApiAccountLoginPost
     */
    readonly Email: string

    /**
     * User\\\&#39;s password.
     * @type {string}
     * @memberof AccountApiApiAccountLoginPost
     */
    readonly Password: string

    /**
     * Client\\\&#39;s timezone.
     * @type {string}
     * @memberof AccountApiApiAccountLoginPost
     */
    readonly clientTimeZone?: string
}

/**
 * AccountApi - object-oriented interface
 * @export
 * @class AccountApi
 * @extends {BaseAPI}
 */
export class AccountApi extends BaseAPI {
    /**
     * 
     * @summary Logs in a user
     * @param {AccountApiApiAccountLoginPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public apiAccountLoginPost(requestParameters: AccountApiApiAccountLoginPostRequest, options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).apiAccountLoginPost(requestParameters.Email, requestParameters.Password, requestParameters.clientTimeZone, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CalendarApi - axios parameter creator
 * @export
 */
export const CalendarApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets information about the user\'s calendars and calendar accounts.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCalendarInfoGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/Calendar/Info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication csrfTokenHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-csrf-token", configuration)

            // authentication cookieAuthAntiforgery required

            // authentication cookieAuthIdentity required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CalendarApi - functional programming interface
 * @export
 */
export const CalendarApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CalendarApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Gets information about the user\'s calendars and calendar accounts.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiCalendarInfoGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CalendarInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiCalendarInfoGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CalendarApi.apiCalendarInfoGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CalendarApi - factory interface
 * @export
 */
export const CalendarApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CalendarApiFp(configuration)
    return {
        /**
         * 
         * @summary Gets information about the user\'s calendars and calendar accounts.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCalendarInfoGet(options?: RawAxiosRequestConfig): AxiosPromise<CalendarInfoResponse> {
            return localVarFp.apiCalendarInfoGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CalendarApi - object-oriented interface
 * @export
 * @class CalendarApi
 * @extends {BaseAPI}
 */
export class CalendarApi extends BaseAPI {
    /**
     * 
     * @summary Gets information about the user\'s calendars and calendar accounts.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CalendarApi
     */
    public apiCalendarInfoGet(options?: RawAxiosRequestConfig) {
        return CalendarApiFp(this.configuration).apiCalendarInfoGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * InboxApi - axios parameter creator
 * @export
 */
export const InboxApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets inbox items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInboxItemsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/Inbox/Items`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication csrfTokenHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-csrf-token", configuration)

            // authentication cookieAuthAntiforgery required

            // authentication cookieAuthIdentity required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InboxApi - functional programming interface
 * @export
 */
export const InboxApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InboxApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Gets inbox items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiInboxItemsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InboxItemsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiInboxItemsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['InboxApi.apiInboxItemsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * InboxApi - factory interface
 * @export
 */
export const InboxApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InboxApiFp(configuration)
    return {
        /**
         * 
         * @summary Gets inbox items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInboxItemsGet(options?: RawAxiosRequestConfig): AxiosPromise<InboxItemsResponse> {
            return localVarFp.apiInboxItemsGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InboxApi - object-oriented interface
 * @export
 * @class InboxApi
 * @extends {BaseAPI}
 */
export class InboxApi extends BaseAPI {
    /**
     * 
     * @summary Gets inbox items
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InboxApi
     */
    public apiInboxItemsGet(options?: RawAxiosRequestConfig) {
        return InboxApiFp(this.configuration).apiInboxItemsGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ItemApi - axios parameter creator
 * @export
 */
export const ItemApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Changes the partial completion status of an item instance or a specific schedule item.
         * @param {number} itemId The ID of the item.
         * @param {number} instanceId The instance ID of the item.
         * @param {number} scheduleItemId The ID of the specific schedule item part being marked.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiItemChangePartialCompleteStatusPost: async (itemId: number, instanceId: number, scheduleItemId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('apiItemChangePartialCompleteStatusPost', 'itemId', itemId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('apiItemChangePartialCompleteStatusPost', 'instanceId', instanceId)
            // verify required parameter 'scheduleItemId' is not null or undefined
            assertParamExists('apiItemChangePartialCompleteStatusPost', 'scheduleItemId', scheduleItemId)
            const localVarPath = `/api/Item/ChangePartialCompleteStatus`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication csrfTokenHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-csrf-token", configuration)

            // authentication cookieAuthAntiforgery required

            // authentication cookieAuthIdentity required


            if (itemId !== undefined) { 
                localVarFormParams.append('itemId', itemId as any);
            }
    
            if (instanceId !== undefined) { 
                localVarFormParams.append('instanceId', instanceId as any);
            }
    
            if (scheduleItemId !== undefined) { 
                localVarFormParams.append('scheduleItemId', scheduleItemId as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a new item (task or event)
         * @param {number} [id] Item ID. 0 for new items.
         * @param {number} [InstanceID] Instance ID of the item, if applicable.
         * @param {string} [Notes] Notes for the item.
         * @param {string | null} [DueDateTime] Due date and time for the item.
         * @param {string} [StartDateTime] Start date and time for the item.
         * @param {string} [EndDateTime] End date and time for the item.
         * @param {string} [DontStartUntil] Do not start until this date and time.
         * @param {string} [TimeZone] Timezone for the item.
         * @param {boolean} [IsAutoIgnored] Whether the item is auto-ignored.
         * @param {string} [Title] Title of the item.
         * @param {string} [ItemType] Type of the item (e.g., task, event).
         * @param {number} [ProgressHours] Progress in hours.
         * @param {number} [ProgressMinutes] Progress in minutes.
         * @param {number} [minLengthTotalMinutes] Minimum length of the item in total minutes.
         * @param {number} [BufferTimeBeforeHours] 
         * @param {number} [BufferTimeBeforeMinutes] 
         * @param {number} [BufferTimeAfterHours] 
         * @param {number} [BufferTimeAfterMinutes] 
         * @param {boolean} [Busy] Whether the item marks time as busy.
         * @param {boolean} [FixedTime] Whether the item has a fixed time.
         * @param {boolean} [AllDay] Whether the item is an all-day event.
         * @param {string} [RepeatType] Repeat type (e.g., Never, Daily, Weekly, Yearly).
         * @param {number} [Interval] 
         * @param {boolean} [Sunday] 
         * @param {boolean} [Monday] 
         * @param {boolean} [Tuesday] 
         * @param {boolean} [Wednesday] 
         * @param {boolean} [Thursday] 
         * @param {boolean} [Friday] 
         * @param {boolean} [Saturday] 
         * @param {string} [MonthlyType] 
         * @param {string | null} [Dates] 
         * @param {number} [MonthOrdinal] 
         * @param {number} [WeekDay] 
         * @param {string} [EndRepeatType] 
         * @param {string} [EndRepeatDate] 
         * @param {number} [NumOccurrences] 
         * @param {number} [priority] Priority of the item.
         * @param {string | null} [customColor] Custom color for the item (hex code).
         * @param {number} [calendarId] ID of the calendar this item belongs to.
         * @param {number | null} [timeProfileId] ID of the time profile associated with this item.
         * @param {string} [tagIds] Comma-separated string of tag IDs for create/update.
         * @param {string | null} [Location] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiItemCreatePost: async (id?: number, InstanceID?: number, Notes?: string, DueDateTime?: string | null, StartDateTime?: string, EndDateTime?: string, DontStartUntil?: string, TimeZone?: string, IsAutoIgnored?: boolean, Title?: string, ItemType?: string, ProgressHours?: number, ProgressMinutes?: number, minLengthTotalMinutes?: number, BufferTimeBeforeHours?: number, BufferTimeBeforeMinutes?: number, BufferTimeAfterHours?: number, BufferTimeAfterMinutes?: number, Busy?: boolean, FixedTime?: boolean, AllDay?: boolean, RepeatType?: string, Interval?: number, Sunday?: boolean, Monday?: boolean, Tuesday?: boolean, Wednesday?: boolean, Thursday?: boolean, Friday?: boolean, Saturday?: boolean, MonthlyType?: string, Dates?: string | null, MonthOrdinal?: number, WeekDay?: number, EndRepeatType?: string, EndRepeatDate?: string, NumOccurrences?: number, priority?: number, customColor?: string | null, calendarId?: number, timeProfileId?: number | null, tagIds?: string, Location?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/Item/Create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication csrfTokenHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-csrf-token", configuration)

            // authentication cookieAuthAntiforgery required

            // authentication cookieAuthIdentity required


            if (id !== undefined) { 
                localVarFormParams.append('id', id as any);
            }
    
            if (InstanceID !== undefined) { 
                localVarFormParams.append('InstanceID', InstanceID as any);
            }
    
            if (Notes !== undefined) { 
                localVarFormParams.append('Notes', Notes as any);
            }
    
            if (DueDateTime !== undefined) { 
                localVarFormParams.append('DueDateTime', DueDateTime as any);
            }
    
            if (StartDateTime !== undefined) { 
                localVarFormParams.append('StartDateTime', StartDateTime as any);
            }
    
            if (EndDateTime !== undefined) { 
                localVarFormParams.append('EndDateTime', EndDateTime as any);
            }
    
            if (DontStartUntil !== undefined) { 
                localVarFormParams.append('DontStartUntil', DontStartUntil as any);
            }
    
            if (TimeZone !== undefined) { 
                localVarFormParams.append('TimeZone', TimeZone as any);
            }
    
            if (IsAutoIgnored !== undefined) { 
                localVarFormParams.append('IsAutoIgnored', String(IsAutoIgnored) as any);
            }
    
            if (Title !== undefined) { 
                localVarFormParams.append('Title', Title as any);
            }
    
            if (ItemType !== undefined) { 
                localVarFormParams.append('ItemType', ItemType as any);
            }
    
            if (ProgressHours !== undefined) { 
                localVarFormParams.append('ProgressHours', ProgressHours as any);
            }
    
            if (ProgressMinutes !== undefined) { 
                localVarFormParams.append('ProgressMinutes', ProgressMinutes as any);
            }
    
            if (minLengthTotalMinutes !== undefined) { 
                localVarFormParams.append('minLengthTotalMinutes', minLengthTotalMinutes as any);
            }
    
            if (BufferTimeBeforeHours !== undefined) { 
                localVarFormParams.append('BufferTimeBeforeHours', BufferTimeBeforeHours as any);
            }
    
            if (BufferTimeBeforeMinutes !== undefined) { 
                localVarFormParams.append('BufferTimeBeforeMinutes', BufferTimeBeforeMinutes as any);
            }
    
            if (BufferTimeAfterHours !== undefined) { 
                localVarFormParams.append('BufferTimeAfterHours', BufferTimeAfterHours as any);
            }
    
            if (BufferTimeAfterMinutes !== undefined) { 
                localVarFormParams.append('BufferTimeAfterMinutes', BufferTimeAfterMinutes as any);
            }
    
            if (Busy !== undefined) { 
                localVarFormParams.append('Busy', String(Busy) as any);
            }
    
            if (FixedTime !== undefined) { 
                localVarFormParams.append('FixedTime', String(FixedTime) as any);
            }
    
            if (AllDay !== undefined) { 
                localVarFormParams.append('AllDay', String(AllDay) as any);
            }
    
            if (RepeatType !== undefined) { 
                localVarFormParams.append('RepeatType', RepeatType as any);
            }
    
            if (Interval !== undefined) { 
                localVarFormParams.append('Interval', Interval as any);
            }
    
            if (Sunday !== undefined) { 
                localVarFormParams.append('Sunday', String(Sunday) as any);
            }
    
            if (Monday !== undefined) { 
                localVarFormParams.append('Monday', String(Monday) as any);
            }
    
            if (Tuesday !== undefined) { 
                localVarFormParams.append('Tuesday', String(Tuesday) as any);
            }
    
            if (Wednesday !== undefined) { 
                localVarFormParams.append('Wednesday', String(Wednesday) as any);
            }
    
            if (Thursday !== undefined) { 
                localVarFormParams.append('Thursday', String(Thursday) as any);
            }
    
            if (Friday !== undefined) { 
                localVarFormParams.append('Friday', String(Friday) as any);
            }
    
            if (Saturday !== undefined) { 
                localVarFormParams.append('Saturday', String(Saturday) as any);
            }
    
            if (MonthlyType !== undefined) { 
                localVarFormParams.append('MonthlyType', MonthlyType as any);
            }
    
            if (Dates !== undefined) { 
                localVarFormParams.append('Dates', Dates as any);
            }
    
            if (MonthOrdinal !== undefined) { 
                localVarFormParams.append('MonthOrdinal', MonthOrdinal as any);
            }
    
            if (WeekDay !== undefined) { 
                localVarFormParams.append('WeekDay', WeekDay as any);
            }
    
            if (EndRepeatType !== undefined) { 
                localVarFormParams.append('EndRepeatType', EndRepeatType as any);
            }
    
            if (EndRepeatDate !== undefined) { 
                localVarFormParams.append('EndRepeatDate', EndRepeatDate as any);
            }
    
            if (NumOccurrences !== undefined) { 
                localVarFormParams.append('NumOccurrences', NumOccurrences as any);
            }
    
            if (priority !== undefined) { 
                localVarFormParams.append('priority', priority as any);
            }
    
            if (customColor !== undefined) { 
                localVarFormParams.append('customColor', customColor as any);
            }
    
            if (calendarId !== undefined) { 
                localVarFormParams.append('calendarId', calendarId as any);
            }
    
            if (timeProfileId !== undefined) { 
                localVarFormParams.append('timeProfileId', timeProfileId as any);
            }
    
            if (tagIds !== undefined) { 
                localVarFormParams.append('tagIds', tagIds as any);
            }
    
            if (Location !== undefined) { 
                localVarFormParams.append('Location', Location as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets an item for editing
         * @param {number} itemId 
         * @param {number} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiItemEditGet: async (itemId: number, instanceId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('apiItemEditGet', 'itemId', itemId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('apiItemEditGet', 'instanceId', instanceId)
            const localVarPath = `/api/Item/Edit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication csrfTokenHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-csrf-token", configuration)

            // authentication cookieAuthAntiforgery required

            // authentication cookieAuthIdentity required

            if (itemId !== undefined) {
                localVarQueryParameter['itemId'] = itemId;
            }

            if (instanceId !== undefined) {
                localVarQueryParameter['instanceId'] = instanceId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Edits an existing item
         * @param {number} id Item ID. 0 for new items.
         * @param {number} [InstanceID] Instance ID of the item, if applicable.
         * @param {string} [Notes] Notes for the item.
         * @param {string | null} [DueDateTime] Due date and time for the item.
         * @param {string} [StartDateTime] Start date and time for the item.
         * @param {string} [EndDateTime] End date and time for the item.
         * @param {string} [DontStartUntil] Do not start until this date and time.
         * @param {string} [TimeZone] Timezone for the item.
         * @param {boolean} [IsAutoIgnored] Whether the item is auto-ignored.
         * @param {string} [Title] Title of the item.
         * @param {string} [ItemType] Type of the item (e.g., task, event).
         * @param {number} [ProgressHours] Progress in hours.
         * @param {number} [ProgressMinutes] Progress in minutes.
         * @param {number} [minLengthTotalMinutes] Minimum length of the item in total minutes.
         * @param {number} [BufferTimeBeforeHours] 
         * @param {number} [BufferTimeBeforeMinutes] 
         * @param {number} [BufferTimeAfterHours] 
         * @param {number} [BufferTimeAfterMinutes] 
         * @param {boolean} [Busy] Whether the item marks time as busy.
         * @param {boolean} [FixedTime] Whether the item has a fixed time.
         * @param {boolean} [AllDay] Whether the item is an all-day event.
         * @param {string} [RepeatType] Repeat type (e.g., Never, Daily, Weekly, Yearly).
         * @param {number} [Interval] 
         * @param {boolean} [Sunday] 
         * @param {boolean} [Monday] 
         * @param {boolean} [Tuesday] 
         * @param {boolean} [Wednesday] 
         * @param {boolean} [Thursday] 
         * @param {boolean} [Friday] 
         * @param {boolean} [Saturday] 
         * @param {string} [MonthlyType] 
         * @param {string | null} [Dates] 
         * @param {number} [MonthOrdinal] 
         * @param {number} [WeekDay] 
         * @param {string} [EndRepeatType] 
         * @param {string} [EndRepeatDate] 
         * @param {number} [NumOccurrences] 
         * @param {number} [priority] Priority of the item.
         * @param {string | null} [customColor] Custom color for the item (hex code).
         * @param {number} [calendarId] ID of the calendar this item belongs to.
         * @param {number | null} [timeProfileId] ID of the time profile associated with this item.
         * @param {string} [tagIds] Comma-separated string of tag IDs for create/update.
         * @param {string | null} [Location] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiItemEditPost: async (id: number, InstanceID?: number, Notes?: string, DueDateTime?: string | null, StartDateTime?: string, EndDateTime?: string, DontStartUntil?: string, TimeZone?: string, IsAutoIgnored?: boolean, Title?: string, ItemType?: string, ProgressHours?: number, ProgressMinutes?: number, minLengthTotalMinutes?: number, BufferTimeBeforeHours?: number, BufferTimeBeforeMinutes?: number, BufferTimeAfterHours?: number, BufferTimeAfterMinutes?: number, Busy?: boolean, FixedTime?: boolean, AllDay?: boolean, RepeatType?: string, Interval?: number, Sunday?: boolean, Monday?: boolean, Tuesday?: boolean, Wednesday?: boolean, Thursday?: boolean, Friday?: boolean, Saturday?: boolean, MonthlyType?: string, Dates?: string | null, MonthOrdinal?: number, WeekDay?: number, EndRepeatType?: string, EndRepeatDate?: string, NumOccurrences?: number, priority?: number, customColor?: string | null, calendarId?: number, timeProfileId?: number | null, tagIds?: string, Location?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiItemEditPost', 'id', id)
            const localVarPath = `/api/Item/Edit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication csrfTokenHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-csrf-token", configuration)

            // authentication cookieAuthAntiforgery required

            // authentication cookieAuthIdentity required


            if (id !== undefined) { 
                localVarFormParams.append('id', id as any);
            }
    
            if (InstanceID !== undefined) { 
                localVarFormParams.append('InstanceID', InstanceID as any);
            }
    
            if (Notes !== undefined) { 
                localVarFormParams.append('Notes', Notes as any);
            }
    
            if (DueDateTime !== undefined) { 
                localVarFormParams.append('DueDateTime', DueDateTime as any);
            }
    
            if (StartDateTime !== undefined) { 
                localVarFormParams.append('StartDateTime', StartDateTime as any);
            }
    
            if (EndDateTime !== undefined) { 
                localVarFormParams.append('EndDateTime', EndDateTime as any);
            }
    
            if (DontStartUntil !== undefined) { 
                localVarFormParams.append('DontStartUntil', DontStartUntil as any);
            }
    
            if (TimeZone !== undefined) { 
                localVarFormParams.append('TimeZone', TimeZone as any);
            }
    
            if (IsAutoIgnored !== undefined) { 
                localVarFormParams.append('IsAutoIgnored', String(IsAutoIgnored) as any);
            }
    
            if (Title !== undefined) { 
                localVarFormParams.append('Title', Title as any);
            }
    
            if (ItemType !== undefined) { 
                localVarFormParams.append('ItemType', ItemType as any);
            }
    
            if (ProgressHours !== undefined) { 
                localVarFormParams.append('ProgressHours', ProgressHours as any);
            }
    
            if (ProgressMinutes !== undefined) { 
                localVarFormParams.append('ProgressMinutes', ProgressMinutes as any);
            }
    
            if (minLengthTotalMinutes !== undefined) { 
                localVarFormParams.append('minLengthTotalMinutes', minLengthTotalMinutes as any);
            }
    
            if (BufferTimeBeforeHours !== undefined) { 
                localVarFormParams.append('BufferTimeBeforeHours', BufferTimeBeforeHours as any);
            }
    
            if (BufferTimeBeforeMinutes !== undefined) { 
                localVarFormParams.append('BufferTimeBeforeMinutes', BufferTimeBeforeMinutes as any);
            }
    
            if (BufferTimeAfterHours !== undefined) { 
                localVarFormParams.append('BufferTimeAfterHours', BufferTimeAfterHours as any);
            }
    
            if (BufferTimeAfterMinutes !== undefined) { 
                localVarFormParams.append('BufferTimeAfterMinutes', BufferTimeAfterMinutes as any);
            }
    
            if (Busy !== undefined) { 
                localVarFormParams.append('Busy', String(Busy) as any);
            }
    
            if (FixedTime !== undefined) { 
                localVarFormParams.append('FixedTime', String(FixedTime) as any);
            }
    
            if (AllDay !== undefined) { 
                localVarFormParams.append('AllDay', String(AllDay) as any);
            }
    
            if (RepeatType !== undefined) { 
                localVarFormParams.append('RepeatType', RepeatType as any);
            }
    
            if (Interval !== undefined) { 
                localVarFormParams.append('Interval', Interval as any);
            }
    
            if (Sunday !== undefined) { 
                localVarFormParams.append('Sunday', String(Sunday) as any);
            }
    
            if (Monday !== undefined) { 
                localVarFormParams.append('Monday', String(Monday) as any);
            }
    
            if (Tuesday !== undefined) { 
                localVarFormParams.append('Tuesday', String(Tuesday) as any);
            }
    
            if (Wednesday !== undefined) { 
                localVarFormParams.append('Wednesday', String(Wednesday) as any);
            }
    
            if (Thursday !== undefined) { 
                localVarFormParams.append('Thursday', String(Thursday) as any);
            }
    
            if (Friday !== undefined) { 
                localVarFormParams.append('Friday', String(Friday) as any);
            }
    
            if (Saturday !== undefined) { 
                localVarFormParams.append('Saturday', String(Saturday) as any);
            }
    
            if (MonthlyType !== undefined) { 
                localVarFormParams.append('MonthlyType', MonthlyType as any);
            }
    
            if (Dates !== undefined) { 
                localVarFormParams.append('Dates', Dates as any);
            }
    
            if (MonthOrdinal !== undefined) { 
                localVarFormParams.append('MonthOrdinal', MonthOrdinal as any);
            }
    
            if (WeekDay !== undefined) { 
                localVarFormParams.append('WeekDay', WeekDay as any);
            }
    
            if (EndRepeatType !== undefined) { 
                localVarFormParams.append('EndRepeatType', EndRepeatType as any);
            }
    
            if (EndRepeatDate !== undefined) { 
                localVarFormParams.append('EndRepeatDate', EndRepeatDate as any);
            }
    
            if (NumOccurrences !== undefined) { 
                localVarFormParams.append('NumOccurrences', NumOccurrences as any);
            }
    
            if (priority !== undefined) { 
                localVarFormParams.append('priority', priority as any);
            }
    
            if (customColor !== undefined) { 
                localVarFormParams.append('customColor', customColor as any);
            }
    
            if (calendarId !== undefined) { 
                localVarFormParams.append('calendarId', calendarId as any);
            }
    
            if (timeProfileId !== undefined) { 
                localVarFormParams.append('timeProfileId', timeProfileId as any);
            }
    
            if (tagIds !== undefined) { 
                localVarFormParams.append('tagIds', tagIds as any);
            }
    
            if (Location !== undefined) { 
                localVarFormParams.append('Location', Location as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes multiple items or instances
         * @param {string} serializedItemIdToInstanceIdsDict A JSON string representing a dictionary of item IDs to instance IDs.
         * @param {string} deleteType Type of delete operation (e.g., deleteAll).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiItemMultipleDeletePost: async (serializedItemIdToInstanceIdsDict: string, deleteType: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serializedItemIdToInstanceIdsDict' is not null or undefined
            assertParamExists('apiItemMultipleDeletePost', 'serializedItemIdToInstanceIdsDict', serializedItemIdToInstanceIdsDict)
            // verify required parameter 'deleteType' is not null or undefined
            assertParamExists('apiItemMultipleDeletePost', 'deleteType', deleteType)
            const localVarPath = `/api/Item/MultipleDelete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication csrfTokenHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-csrf-token", configuration)

            // authentication cookieAuthAntiforgery required

            // authentication cookieAuthIdentity required


            if (serializedItemIdToInstanceIdsDict !== undefined) { 
                localVarFormParams.append('serializedItemIdToInstanceIdsDict', serializedItemIdToInstanceIdsDict as any);
            }
    
            if (deleteType !== undefined) { 
                localVarFormParams.append('deleteType', deleteType as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Searches for items based on a query string and other filters.
         * @param {string} query The search term to query items by. Can be \&quot;all\&quot; to fetch many items.
         * @param {boolean} searchCompletedTasks Whether to include completed tasks in the search results.
         * @param {boolean} getItemsAfterCursor Flag for pagination, typically true for initial load or next page.
         * @param {boolean} takeFirst Flag for pagination, typically true for initial load.
         * @param {number} batchSize The number of items to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiItemSearchGet: async (query: string, searchCompletedTasks: boolean, getItemsAfterCursor: boolean, takeFirst: boolean, batchSize: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'query' is not null or undefined
            assertParamExists('apiItemSearchGet', 'query', query)
            // verify required parameter 'searchCompletedTasks' is not null or undefined
            assertParamExists('apiItemSearchGet', 'searchCompletedTasks', searchCompletedTasks)
            // verify required parameter 'getItemsAfterCursor' is not null or undefined
            assertParamExists('apiItemSearchGet', 'getItemsAfterCursor', getItemsAfterCursor)
            // verify required parameter 'takeFirst' is not null or undefined
            assertParamExists('apiItemSearchGet', 'takeFirst', takeFirst)
            // verify required parameter 'batchSize' is not null or undefined
            assertParamExists('apiItemSearchGet', 'batchSize', batchSize)
            const localVarPath = `/api/item/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication csrfTokenHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-csrf-token", configuration)

            // authentication cookieAuthAntiforgery required

            // authentication cookieAuthIdentity required

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (searchCompletedTasks !== undefined) {
                localVarQueryParameter['searchCompletedTasks'] = searchCompletedTasks;
            }

            if (getItemsAfterCursor !== undefined) {
                localVarQueryParameter['getItemsAfterCursor'] = getItemsAfterCursor;
            }

            if (takeFirst !== undefined) {
                localVarQueryParameter['takeFirst'] = takeFirst;
            }

            if (batchSize !== undefined) {
                localVarQueryParameter['batchSize'] = batchSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemApi - functional programming interface
 * @export
 */
export const ItemApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ItemApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Changes the partial completion status of an item instance or a specific schedule item.
         * @param {number} itemId The ID of the item.
         * @param {number} instanceId The instance ID of the item.
         * @param {number} scheduleItemId The ID of the specific schedule item part being marked.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiItemChangePartialCompleteStatusPost(itemId: number, instanceId: number, scheduleItemId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChangePartialCompleteStatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiItemChangePartialCompleteStatusPost(itemId, instanceId, scheduleItemId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemApi.apiItemChangePartialCompleteStatusPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Creates a new item (task or event)
         * @param {number} [id] Item ID. 0 for new items.
         * @param {number} [InstanceID] Instance ID of the item, if applicable.
         * @param {string} [Notes] Notes for the item.
         * @param {string | null} [DueDateTime] Due date and time for the item.
         * @param {string} [StartDateTime] Start date and time for the item.
         * @param {string} [EndDateTime] End date and time for the item.
         * @param {string} [DontStartUntil] Do not start until this date and time.
         * @param {string} [TimeZone] Timezone for the item.
         * @param {boolean} [IsAutoIgnored] Whether the item is auto-ignored.
         * @param {string} [Title] Title of the item.
         * @param {string} [ItemType] Type of the item (e.g., task, event).
         * @param {number} [ProgressHours] Progress in hours.
         * @param {number} [ProgressMinutes] Progress in minutes.
         * @param {number} [minLengthTotalMinutes] Minimum length of the item in total minutes.
         * @param {number} [BufferTimeBeforeHours] 
         * @param {number} [BufferTimeBeforeMinutes] 
         * @param {number} [BufferTimeAfterHours] 
         * @param {number} [BufferTimeAfterMinutes] 
         * @param {boolean} [Busy] Whether the item marks time as busy.
         * @param {boolean} [FixedTime] Whether the item has a fixed time.
         * @param {boolean} [AllDay] Whether the item is an all-day event.
         * @param {string} [RepeatType] Repeat type (e.g., Never, Daily, Weekly, Yearly).
         * @param {number} [Interval] 
         * @param {boolean} [Sunday] 
         * @param {boolean} [Monday] 
         * @param {boolean} [Tuesday] 
         * @param {boolean} [Wednesday] 
         * @param {boolean} [Thursday] 
         * @param {boolean} [Friday] 
         * @param {boolean} [Saturday] 
         * @param {string} [MonthlyType] 
         * @param {string | null} [Dates] 
         * @param {number} [MonthOrdinal] 
         * @param {number} [WeekDay] 
         * @param {string} [EndRepeatType] 
         * @param {string} [EndRepeatDate] 
         * @param {number} [NumOccurrences] 
         * @param {number} [priority] Priority of the item.
         * @param {string | null} [customColor] Custom color for the item (hex code).
         * @param {number} [calendarId] ID of the calendar this item belongs to.
         * @param {number | null} [timeProfileId] ID of the time profile associated with this item.
         * @param {string} [tagIds] Comma-separated string of tag IDs for create/update.
         * @param {string | null} [Location] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiItemCreatePost(id?: number, InstanceID?: number, Notes?: string, DueDateTime?: string | null, StartDateTime?: string, EndDateTime?: string, DontStartUntil?: string, TimeZone?: string, IsAutoIgnored?: boolean, Title?: string, ItemType?: string, ProgressHours?: number, ProgressMinutes?: number, minLengthTotalMinutes?: number, BufferTimeBeforeHours?: number, BufferTimeBeforeMinutes?: number, BufferTimeAfterHours?: number, BufferTimeAfterMinutes?: number, Busy?: boolean, FixedTime?: boolean, AllDay?: boolean, RepeatType?: string, Interval?: number, Sunday?: boolean, Monday?: boolean, Tuesday?: boolean, Wednesday?: boolean, Thursday?: boolean, Friday?: boolean, Saturday?: boolean, MonthlyType?: string, Dates?: string | null, MonthOrdinal?: number, WeekDay?: number, EndRepeatType?: string, EndRepeatDate?: string, NumOccurrences?: number, priority?: number, customColor?: string | null, calendarId?: number, timeProfileId?: number | null, tagIds?: string, Location?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiItemCreatePost(id, InstanceID, Notes, DueDateTime, StartDateTime, EndDateTime, DontStartUntil, TimeZone, IsAutoIgnored, Title, ItemType, ProgressHours, ProgressMinutes, minLengthTotalMinutes, BufferTimeBeforeHours, BufferTimeBeforeMinutes, BufferTimeAfterHours, BufferTimeAfterMinutes, Busy, FixedTime, AllDay, RepeatType, Interval, Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, MonthlyType, Dates, MonthOrdinal, WeekDay, EndRepeatType, EndRepeatDate, NumOccurrences, priority, customColor, calendarId, timeProfileId, tagIds, Location, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemApi.apiItemCreatePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Gets an item for editing
         * @param {number} itemId 
         * @param {number} instanceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiItemEditGet(itemId: number, instanceId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemEditGetDataResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiItemEditGet(itemId, instanceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemApi.apiItemEditGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Edits an existing item
         * @param {number} id Item ID. 0 for new items.
         * @param {number} [InstanceID] Instance ID of the item, if applicable.
         * @param {string} [Notes] Notes for the item.
         * @param {string | null} [DueDateTime] Due date and time for the item.
         * @param {string} [StartDateTime] Start date and time for the item.
         * @param {string} [EndDateTime] End date and time for the item.
         * @param {string} [DontStartUntil] Do not start until this date and time.
         * @param {string} [TimeZone] Timezone for the item.
         * @param {boolean} [IsAutoIgnored] Whether the item is auto-ignored.
         * @param {string} [Title] Title of the item.
         * @param {string} [ItemType] Type of the item (e.g., task, event).
         * @param {number} [ProgressHours] Progress in hours.
         * @param {number} [ProgressMinutes] Progress in minutes.
         * @param {number} [minLengthTotalMinutes] Minimum length of the item in total minutes.
         * @param {number} [BufferTimeBeforeHours] 
         * @param {number} [BufferTimeBeforeMinutes] 
         * @param {number} [BufferTimeAfterHours] 
         * @param {number} [BufferTimeAfterMinutes] 
         * @param {boolean} [Busy] Whether the item marks time as busy.
         * @param {boolean} [FixedTime] Whether the item has a fixed time.
         * @param {boolean} [AllDay] Whether the item is an all-day event.
         * @param {string} [RepeatType] Repeat type (e.g., Never, Daily, Weekly, Yearly).
         * @param {number} [Interval] 
         * @param {boolean} [Sunday] 
         * @param {boolean} [Monday] 
         * @param {boolean} [Tuesday] 
         * @param {boolean} [Wednesday] 
         * @param {boolean} [Thursday] 
         * @param {boolean} [Friday] 
         * @param {boolean} [Saturday] 
         * @param {string} [MonthlyType] 
         * @param {string | null} [Dates] 
         * @param {number} [MonthOrdinal] 
         * @param {number} [WeekDay] 
         * @param {string} [EndRepeatType] 
         * @param {string} [EndRepeatDate] 
         * @param {number} [NumOccurrences] 
         * @param {number} [priority] Priority of the item.
         * @param {string | null} [customColor] Custom color for the item (hex code).
         * @param {number} [calendarId] ID of the calendar this item belongs to.
         * @param {number | null} [timeProfileId] ID of the time profile associated with this item.
         * @param {string} [tagIds] Comma-separated string of tag IDs for create/update.
         * @param {string | null} [Location] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiItemEditPost(id: number, InstanceID?: number, Notes?: string, DueDateTime?: string | null, StartDateTime?: string, EndDateTime?: string, DontStartUntil?: string, TimeZone?: string, IsAutoIgnored?: boolean, Title?: string, ItemType?: string, ProgressHours?: number, ProgressMinutes?: number, minLengthTotalMinutes?: number, BufferTimeBeforeHours?: number, BufferTimeBeforeMinutes?: number, BufferTimeAfterHours?: number, BufferTimeAfterMinutes?: number, Busy?: boolean, FixedTime?: boolean, AllDay?: boolean, RepeatType?: string, Interval?: number, Sunday?: boolean, Monday?: boolean, Tuesday?: boolean, Wednesday?: boolean, Thursday?: boolean, Friday?: boolean, Saturday?: boolean, MonthlyType?: string, Dates?: string | null, MonthOrdinal?: number, WeekDay?: number, EndRepeatType?: string, EndRepeatDate?: string, NumOccurrences?: number, priority?: number, customColor?: string | null, calendarId?: number, timeProfileId?: number | null, tagIds?: string, Location?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemEditResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiItemEditPost(id, InstanceID, Notes, DueDateTime, StartDateTime, EndDateTime, DontStartUntil, TimeZone, IsAutoIgnored, Title, ItemType, ProgressHours, ProgressMinutes, minLengthTotalMinutes, BufferTimeBeforeHours, BufferTimeBeforeMinutes, BufferTimeAfterHours, BufferTimeAfterMinutes, Busy, FixedTime, AllDay, RepeatType, Interval, Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, MonthlyType, Dates, MonthOrdinal, WeekDay, EndRepeatType, EndRepeatDate, NumOccurrences, priority, customColor, calendarId, timeProfileId, tagIds, Location, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemApi.apiItemEditPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Deletes multiple items or instances
         * @param {string} serializedItemIdToInstanceIdsDict A JSON string representing a dictionary of item IDs to instance IDs.
         * @param {string} deleteType Type of delete operation (e.g., deleteAll).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiItemMultipleDeletePost(serializedItemIdToInstanceIdsDict: string, deleteType: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MultipleDeleteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiItemMultipleDeletePost(serializedItemIdToInstanceIdsDict, deleteType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemApi.apiItemMultipleDeletePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Searches for items based on a query string and other filters.
         * @param {string} query The search term to query items by. Can be \&quot;all\&quot; to fetch many items.
         * @param {boolean} searchCompletedTasks Whether to include completed tasks in the search results.
         * @param {boolean} getItemsAfterCursor Flag for pagination, typically true for initial load or next page.
         * @param {boolean} takeFirst Flag for pagination, typically true for initial load.
         * @param {number} batchSize The number of items to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiItemSearchGet(query: string, searchCompletedTasks: boolean, getItemsAfterCursor: boolean, takeFirst: boolean, batchSize: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchResponseWrapper>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiItemSearchGet(query, searchCompletedTasks, getItemsAfterCursor, takeFirst, batchSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ItemApi.apiItemSearchGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ItemApi - factory interface
 * @export
 */
export const ItemApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ItemApiFp(configuration)
    return {
        /**
         * 
         * @summary Changes the partial completion status of an item instance or a specific schedule item.
         * @param {ItemApiApiItemChangePartialCompleteStatusPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiItemChangePartialCompleteStatusPost(requestParameters: ItemApiApiItemChangePartialCompleteStatusPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ChangePartialCompleteStatusResponse> {
            return localVarFp.apiItemChangePartialCompleteStatusPost(requestParameters.itemId, requestParameters.instanceId, requestParameters.scheduleItemId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a new item (task or event)
         * @param {ItemApiApiItemCreatePostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiItemCreatePost(requestParameters: ItemApiApiItemCreatePostRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<ItemCreateResponse> {
            return localVarFp.apiItemCreatePost(requestParameters.id, requestParameters.InstanceID, requestParameters.Notes, requestParameters.DueDateTime, requestParameters.StartDateTime, requestParameters.EndDateTime, requestParameters.DontStartUntil, requestParameters.TimeZone, requestParameters.IsAutoIgnored, requestParameters.Title, requestParameters.ItemType, requestParameters.ProgressHours, requestParameters.ProgressMinutes, requestParameters.minLengthTotalMinutes, requestParameters.BufferTimeBeforeHours, requestParameters.BufferTimeBeforeMinutes, requestParameters.BufferTimeAfterHours, requestParameters.BufferTimeAfterMinutes, requestParameters.Busy, requestParameters.FixedTime, requestParameters.AllDay, requestParameters.RepeatType, requestParameters.Interval, requestParameters.Sunday, requestParameters.Monday, requestParameters.Tuesday, requestParameters.Wednesday, requestParameters.Thursday, requestParameters.Friday, requestParameters.Saturday, requestParameters.MonthlyType, requestParameters.Dates, requestParameters.MonthOrdinal, requestParameters.WeekDay, requestParameters.EndRepeatType, requestParameters.EndRepeatDate, requestParameters.NumOccurrences, requestParameters.priority, requestParameters.customColor, requestParameters.calendarId, requestParameters.timeProfileId, requestParameters.tagIds, requestParameters.Location, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets an item for editing
         * @param {ItemApiApiItemEditGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiItemEditGet(requestParameters: ItemApiApiItemEditGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<ItemEditGetDataResponse> {
            return localVarFp.apiItemEditGet(requestParameters.itemId, requestParameters.instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Edits an existing item
         * @param {ItemApiApiItemEditPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiItemEditPost(requestParameters: ItemApiApiItemEditPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ItemEditResponse> {
            return localVarFp.apiItemEditPost(requestParameters.id, requestParameters.InstanceID, requestParameters.Notes, requestParameters.DueDateTime, requestParameters.StartDateTime, requestParameters.EndDateTime, requestParameters.DontStartUntil, requestParameters.TimeZone, requestParameters.IsAutoIgnored, requestParameters.Title, requestParameters.ItemType, requestParameters.ProgressHours, requestParameters.ProgressMinutes, requestParameters.minLengthTotalMinutes, requestParameters.BufferTimeBeforeHours, requestParameters.BufferTimeBeforeMinutes, requestParameters.BufferTimeAfterHours, requestParameters.BufferTimeAfterMinutes, requestParameters.Busy, requestParameters.FixedTime, requestParameters.AllDay, requestParameters.RepeatType, requestParameters.Interval, requestParameters.Sunday, requestParameters.Monday, requestParameters.Tuesday, requestParameters.Wednesday, requestParameters.Thursday, requestParameters.Friday, requestParameters.Saturday, requestParameters.MonthlyType, requestParameters.Dates, requestParameters.MonthOrdinal, requestParameters.WeekDay, requestParameters.EndRepeatType, requestParameters.EndRepeatDate, requestParameters.NumOccurrences, requestParameters.priority, requestParameters.customColor, requestParameters.calendarId, requestParameters.timeProfileId, requestParameters.tagIds, requestParameters.Location, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes multiple items or instances
         * @param {ItemApiApiItemMultipleDeletePostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiItemMultipleDeletePost(requestParameters: ItemApiApiItemMultipleDeletePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<MultipleDeleteResponse> {
            return localVarFp.apiItemMultipleDeletePost(requestParameters.serializedItemIdToInstanceIdsDict, requestParameters.deleteType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Searches for items based on a query string and other filters.
         * @param {ItemApiApiItemSearchGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiItemSearchGet(requestParameters: ItemApiApiItemSearchGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<SearchResponseWrapper> {
            return localVarFp.apiItemSearchGet(requestParameters.query, requestParameters.searchCompletedTasks, requestParameters.getItemsAfterCursor, requestParameters.takeFirst, requestParameters.batchSize, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for apiItemChangePartialCompleteStatusPost operation in ItemApi.
 * @export
 * @interface ItemApiApiItemChangePartialCompleteStatusPostRequest
 */
export interface ItemApiApiItemChangePartialCompleteStatusPostRequest {
    /**
     * The ID of the item.
     * @type {number}
     * @memberof ItemApiApiItemChangePartialCompleteStatusPost
     */
    readonly itemId: number

    /**
     * The instance ID of the item.
     * @type {number}
     * @memberof ItemApiApiItemChangePartialCompleteStatusPost
     */
    readonly instanceId: number

    /**
     * The ID of the specific schedule item part being marked.
     * @type {number}
     * @memberof ItemApiApiItemChangePartialCompleteStatusPost
     */
    readonly scheduleItemId: number
}

/**
 * Request parameters for apiItemCreatePost operation in ItemApi.
 * @export
 * @interface ItemApiApiItemCreatePostRequest
 */
export interface ItemApiApiItemCreatePostRequest {
    /**
     * Item ID. 0 for new items.
     * @type {number}
     * @memberof ItemApiApiItemCreatePost
     */
    readonly id?: number

    /**
     * Instance ID of the item, if applicable.
     * @type {number}
     * @memberof ItemApiApiItemCreatePost
     */
    readonly InstanceID?: number

    /**
     * Notes for the item.
     * @type {string}
     * @memberof ItemApiApiItemCreatePost
     */
    readonly Notes?: string

    /**
     * Due date and time for the item.
     * @type {string}
     * @memberof ItemApiApiItemCreatePost
     */
    readonly DueDateTime?: string | null

    /**
     * Start date and time for the item.
     * @type {string}
     * @memberof ItemApiApiItemCreatePost
     */
    readonly StartDateTime?: string

    /**
     * End date and time for the item.
     * @type {string}
     * @memberof ItemApiApiItemCreatePost
     */
    readonly EndDateTime?: string

    /**
     * Do not start until this date and time.
     * @type {string}
     * @memberof ItemApiApiItemCreatePost
     */
    readonly DontStartUntil?: string

    /**
     * Timezone for the item.
     * @type {string}
     * @memberof ItemApiApiItemCreatePost
     */
    readonly TimeZone?: string

    /**
     * Whether the item is auto-ignored.
     * @type {boolean}
     * @memberof ItemApiApiItemCreatePost
     */
    readonly IsAutoIgnored?: boolean

    /**
     * Title of the item.
     * @type {string}
     * @memberof ItemApiApiItemCreatePost
     */
    readonly Title?: string

    /**
     * Type of the item (e.g., task, event).
     * @type {string}
     * @memberof ItemApiApiItemCreatePost
     */
    readonly ItemType?: string

    /**
     * Progress in hours.
     * @type {number}
     * @memberof ItemApiApiItemCreatePost
     */
    readonly ProgressHours?: number

    /**
     * Progress in minutes.
     * @type {number}
     * @memberof ItemApiApiItemCreatePost
     */
    readonly ProgressMinutes?: number

    /**
     * Minimum length of the item in total minutes.
     * @type {number}
     * @memberof ItemApiApiItemCreatePost
     */
    readonly minLengthTotalMinutes?: number

    /**
     * 
     * @type {number}
     * @memberof ItemApiApiItemCreatePost
     */
    readonly BufferTimeBeforeHours?: number

    /**
     * 
     * @type {number}
     * @memberof ItemApiApiItemCreatePost
     */
    readonly BufferTimeBeforeMinutes?: number

    /**
     * 
     * @type {number}
     * @memberof ItemApiApiItemCreatePost
     */
    readonly BufferTimeAfterHours?: number

    /**
     * 
     * @type {number}
     * @memberof ItemApiApiItemCreatePost
     */
    readonly BufferTimeAfterMinutes?: number

    /**
     * Whether the item marks time as busy.
     * @type {boolean}
     * @memberof ItemApiApiItemCreatePost
     */
    readonly Busy?: boolean

    /**
     * Whether the item has a fixed time.
     * @type {boolean}
     * @memberof ItemApiApiItemCreatePost
     */
    readonly FixedTime?: boolean

    /**
     * Whether the item is an all-day event.
     * @type {boolean}
     * @memberof ItemApiApiItemCreatePost
     */
    readonly AllDay?: boolean

    /**
     * Repeat type (e.g., Never, Daily, Weekly, Yearly).
     * @type {string}
     * @memberof ItemApiApiItemCreatePost
     */
    readonly RepeatType?: string

    /**
     * 
     * @type {number}
     * @memberof ItemApiApiItemCreatePost
     */
    readonly Interval?: number

    /**
     * 
     * @type {boolean}
     * @memberof ItemApiApiItemCreatePost
     */
    readonly Sunday?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof ItemApiApiItemCreatePost
     */
    readonly Monday?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof ItemApiApiItemCreatePost
     */
    readonly Tuesday?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof ItemApiApiItemCreatePost
     */
    readonly Wednesday?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof ItemApiApiItemCreatePost
     */
    readonly Thursday?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof ItemApiApiItemCreatePost
     */
    readonly Friday?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof ItemApiApiItemCreatePost
     */
    readonly Saturday?: boolean

    /**
     * 
     * @type {string}
     * @memberof ItemApiApiItemCreatePost
     */
    readonly MonthlyType?: string

    /**
     * 
     * @type {string}
     * @memberof ItemApiApiItemCreatePost
     */
    readonly Dates?: string | null

    /**
     * 
     * @type {number}
     * @memberof ItemApiApiItemCreatePost
     */
    readonly MonthOrdinal?: number

    /**
     * 
     * @type {number}
     * @memberof ItemApiApiItemCreatePost
     */
    readonly WeekDay?: number

    /**
     * 
     * @type {string}
     * @memberof ItemApiApiItemCreatePost
     */
    readonly EndRepeatType?: string

    /**
     * 
     * @type {string}
     * @memberof ItemApiApiItemCreatePost
     */
    readonly EndRepeatDate?: string

    /**
     * 
     * @type {number}
     * @memberof ItemApiApiItemCreatePost
     */
    readonly NumOccurrences?: number

    /**
     * Priority of the item.
     * @type {number}
     * @memberof ItemApiApiItemCreatePost
     */
    readonly priority?: number

    /**
     * Custom color for the item (hex code).
     * @type {string}
     * @memberof ItemApiApiItemCreatePost
     */
    readonly customColor?: string | null

    /**
     * ID of the calendar this item belongs to.
     * @type {number}
     * @memberof ItemApiApiItemCreatePost
     */
    readonly calendarId?: number

    /**
     * ID of the time profile associated with this item.
     * @type {number}
     * @memberof ItemApiApiItemCreatePost
     */
    readonly timeProfileId?: number | null

    /**
     * Comma-separated string of tag IDs for create/update.
     * @type {string}
     * @memberof ItemApiApiItemCreatePost
     */
    readonly tagIds?: string

    /**
     * 
     * @type {string}
     * @memberof ItemApiApiItemCreatePost
     */
    readonly Location?: string | null
}

/**
 * Request parameters for apiItemEditGet operation in ItemApi.
 * @export
 * @interface ItemApiApiItemEditGetRequest
 */
export interface ItemApiApiItemEditGetRequest {
    /**
     * 
     * @type {number}
     * @memberof ItemApiApiItemEditGet
     */
    readonly itemId: number

    /**
     * 
     * @type {number}
     * @memberof ItemApiApiItemEditGet
     */
    readonly instanceId: number
}

/**
 * Request parameters for apiItemEditPost operation in ItemApi.
 * @export
 * @interface ItemApiApiItemEditPostRequest
 */
export interface ItemApiApiItemEditPostRequest {
    /**
     * Item ID. 0 for new items.
     * @type {number}
     * @memberof ItemApiApiItemEditPost
     */
    readonly id: number

    /**
     * Instance ID of the item, if applicable.
     * @type {number}
     * @memberof ItemApiApiItemEditPost
     */
    readonly InstanceID?: number

    /**
     * Notes for the item.
     * @type {string}
     * @memberof ItemApiApiItemEditPost
     */
    readonly Notes?: string

    /**
     * Due date and time for the item.
     * @type {string}
     * @memberof ItemApiApiItemEditPost
     */
    readonly DueDateTime?: string | null

    /**
     * Start date and time for the item.
     * @type {string}
     * @memberof ItemApiApiItemEditPost
     */
    readonly StartDateTime?: string

    /**
     * End date and time for the item.
     * @type {string}
     * @memberof ItemApiApiItemEditPost
     */
    readonly EndDateTime?: string

    /**
     * Do not start until this date and time.
     * @type {string}
     * @memberof ItemApiApiItemEditPost
     */
    readonly DontStartUntil?: string

    /**
     * Timezone for the item.
     * @type {string}
     * @memberof ItemApiApiItemEditPost
     */
    readonly TimeZone?: string

    /**
     * Whether the item is auto-ignored.
     * @type {boolean}
     * @memberof ItemApiApiItemEditPost
     */
    readonly IsAutoIgnored?: boolean

    /**
     * Title of the item.
     * @type {string}
     * @memberof ItemApiApiItemEditPost
     */
    readonly Title?: string

    /**
     * Type of the item (e.g., task, event).
     * @type {string}
     * @memberof ItemApiApiItemEditPost
     */
    readonly ItemType?: string

    /**
     * Progress in hours.
     * @type {number}
     * @memberof ItemApiApiItemEditPost
     */
    readonly ProgressHours?: number

    /**
     * Progress in minutes.
     * @type {number}
     * @memberof ItemApiApiItemEditPost
     */
    readonly ProgressMinutes?: number

    /**
     * Minimum length of the item in total minutes.
     * @type {number}
     * @memberof ItemApiApiItemEditPost
     */
    readonly minLengthTotalMinutes?: number

    /**
     * 
     * @type {number}
     * @memberof ItemApiApiItemEditPost
     */
    readonly BufferTimeBeforeHours?: number

    /**
     * 
     * @type {number}
     * @memberof ItemApiApiItemEditPost
     */
    readonly BufferTimeBeforeMinutes?: number

    /**
     * 
     * @type {number}
     * @memberof ItemApiApiItemEditPost
     */
    readonly BufferTimeAfterHours?: number

    /**
     * 
     * @type {number}
     * @memberof ItemApiApiItemEditPost
     */
    readonly BufferTimeAfterMinutes?: number

    /**
     * Whether the item marks time as busy.
     * @type {boolean}
     * @memberof ItemApiApiItemEditPost
     */
    readonly Busy?: boolean

    /**
     * Whether the item has a fixed time.
     * @type {boolean}
     * @memberof ItemApiApiItemEditPost
     */
    readonly FixedTime?: boolean

    /**
     * Whether the item is an all-day event.
     * @type {boolean}
     * @memberof ItemApiApiItemEditPost
     */
    readonly AllDay?: boolean

    /**
     * Repeat type (e.g., Never, Daily, Weekly, Yearly).
     * @type {string}
     * @memberof ItemApiApiItemEditPost
     */
    readonly RepeatType?: string

    /**
     * 
     * @type {number}
     * @memberof ItemApiApiItemEditPost
     */
    readonly Interval?: number

    /**
     * 
     * @type {boolean}
     * @memberof ItemApiApiItemEditPost
     */
    readonly Sunday?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof ItemApiApiItemEditPost
     */
    readonly Monday?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof ItemApiApiItemEditPost
     */
    readonly Tuesday?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof ItemApiApiItemEditPost
     */
    readonly Wednesday?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof ItemApiApiItemEditPost
     */
    readonly Thursday?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof ItemApiApiItemEditPost
     */
    readonly Friday?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof ItemApiApiItemEditPost
     */
    readonly Saturday?: boolean

    /**
     * 
     * @type {string}
     * @memberof ItemApiApiItemEditPost
     */
    readonly MonthlyType?: string

    /**
     * 
     * @type {string}
     * @memberof ItemApiApiItemEditPost
     */
    readonly Dates?: string | null

    /**
     * 
     * @type {number}
     * @memberof ItemApiApiItemEditPost
     */
    readonly MonthOrdinal?: number

    /**
     * 
     * @type {number}
     * @memberof ItemApiApiItemEditPost
     */
    readonly WeekDay?: number

    /**
     * 
     * @type {string}
     * @memberof ItemApiApiItemEditPost
     */
    readonly EndRepeatType?: string

    /**
     * 
     * @type {string}
     * @memberof ItemApiApiItemEditPost
     */
    readonly EndRepeatDate?: string

    /**
     * 
     * @type {number}
     * @memberof ItemApiApiItemEditPost
     */
    readonly NumOccurrences?: number

    /**
     * Priority of the item.
     * @type {number}
     * @memberof ItemApiApiItemEditPost
     */
    readonly priority?: number

    /**
     * Custom color for the item (hex code).
     * @type {string}
     * @memberof ItemApiApiItemEditPost
     */
    readonly customColor?: string | null

    /**
     * ID of the calendar this item belongs to.
     * @type {number}
     * @memberof ItemApiApiItemEditPost
     */
    readonly calendarId?: number

    /**
     * ID of the time profile associated with this item.
     * @type {number}
     * @memberof ItemApiApiItemEditPost
     */
    readonly timeProfileId?: number | null

    /**
     * Comma-separated string of tag IDs for create/update.
     * @type {string}
     * @memberof ItemApiApiItemEditPost
     */
    readonly tagIds?: string

    /**
     * 
     * @type {string}
     * @memberof ItemApiApiItemEditPost
     */
    readonly Location?: string | null
}

/**
 * Request parameters for apiItemMultipleDeletePost operation in ItemApi.
 * @export
 * @interface ItemApiApiItemMultipleDeletePostRequest
 */
export interface ItemApiApiItemMultipleDeletePostRequest {
    /**
     * A JSON string representing a dictionary of item IDs to instance IDs.
     * @type {string}
     * @memberof ItemApiApiItemMultipleDeletePost
     */
    readonly serializedItemIdToInstanceIdsDict: string

    /**
     * Type of delete operation (e.g., deleteAll).
     * @type {string}
     * @memberof ItemApiApiItemMultipleDeletePost
     */
    readonly deleteType: string
}

/**
 * Request parameters for apiItemSearchGet operation in ItemApi.
 * @export
 * @interface ItemApiApiItemSearchGetRequest
 */
export interface ItemApiApiItemSearchGetRequest {
    /**
     * The search term to query items by. Can be \&quot;all\&quot; to fetch many items.
     * @type {string}
     * @memberof ItemApiApiItemSearchGet
     */
    readonly query: string

    /**
     * Whether to include completed tasks in the search results.
     * @type {boolean}
     * @memberof ItemApiApiItemSearchGet
     */
    readonly searchCompletedTasks: boolean

    /**
     * Flag for pagination, typically true for initial load or next page.
     * @type {boolean}
     * @memberof ItemApiApiItemSearchGet
     */
    readonly getItemsAfterCursor: boolean

    /**
     * Flag for pagination, typically true for initial load.
     * @type {boolean}
     * @memberof ItemApiApiItemSearchGet
     */
    readonly takeFirst: boolean

    /**
     * The number of items to return per page.
     * @type {number}
     * @memberof ItemApiApiItemSearchGet
     */
    readonly batchSize: number
}

/**
 * ItemApi - object-oriented interface
 * @export
 * @class ItemApi
 * @extends {BaseAPI}
 */
export class ItemApi extends BaseAPI {
    /**
     * 
     * @summary Changes the partial completion status of an item instance or a specific schedule item.
     * @param {ItemApiApiItemChangePartialCompleteStatusPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public apiItemChangePartialCompleteStatusPost(requestParameters: ItemApiApiItemChangePartialCompleteStatusPostRequest, options?: RawAxiosRequestConfig) {
        return ItemApiFp(this.configuration).apiItemChangePartialCompleteStatusPost(requestParameters.itemId, requestParameters.instanceId, requestParameters.scheduleItemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a new item (task or event)
     * @param {ItemApiApiItemCreatePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public apiItemCreatePost(requestParameters: ItemApiApiItemCreatePostRequest = {}, options?: RawAxiosRequestConfig) {
        return ItemApiFp(this.configuration).apiItemCreatePost(requestParameters.id, requestParameters.InstanceID, requestParameters.Notes, requestParameters.DueDateTime, requestParameters.StartDateTime, requestParameters.EndDateTime, requestParameters.DontStartUntil, requestParameters.TimeZone, requestParameters.IsAutoIgnored, requestParameters.Title, requestParameters.ItemType, requestParameters.ProgressHours, requestParameters.ProgressMinutes, requestParameters.minLengthTotalMinutes, requestParameters.BufferTimeBeforeHours, requestParameters.BufferTimeBeforeMinutes, requestParameters.BufferTimeAfterHours, requestParameters.BufferTimeAfterMinutes, requestParameters.Busy, requestParameters.FixedTime, requestParameters.AllDay, requestParameters.RepeatType, requestParameters.Interval, requestParameters.Sunday, requestParameters.Monday, requestParameters.Tuesday, requestParameters.Wednesday, requestParameters.Thursday, requestParameters.Friday, requestParameters.Saturday, requestParameters.MonthlyType, requestParameters.Dates, requestParameters.MonthOrdinal, requestParameters.WeekDay, requestParameters.EndRepeatType, requestParameters.EndRepeatDate, requestParameters.NumOccurrences, requestParameters.priority, requestParameters.customColor, requestParameters.calendarId, requestParameters.timeProfileId, requestParameters.tagIds, requestParameters.Location, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets an item for editing
     * @param {ItemApiApiItemEditGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public apiItemEditGet(requestParameters: ItemApiApiItemEditGetRequest, options?: RawAxiosRequestConfig) {
        return ItemApiFp(this.configuration).apiItemEditGet(requestParameters.itemId, requestParameters.instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Edits an existing item
     * @param {ItemApiApiItemEditPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public apiItemEditPost(requestParameters: ItemApiApiItemEditPostRequest, options?: RawAxiosRequestConfig) {
        return ItemApiFp(this.configuration).apiItemEditPost(requestParameters.id, requestParameters.InstanceID, requestParameters.Notes, requestParameters.DueDateTime, requestParameters.StartDateTime, requestParameters.EndDateTime, requestParameters.DontStartUntil, requestParameters.TimeZone, requestParameters.IsAutoIgnored, requestParameters.Title, requestParameters.ItemType, requestParameters.ProgressHours, requestParameters.ProgressMinutes, requestParameters.minLengthTotalMinutes, requestParameters.BufferTimeBeforeHours, requestParameters.BufferTimeBeforeMinutes, requestParameters.BufferTimeAfterHours, requestParameters.BufferTimeAfterMinutes, requestParameters.Busy, requestParameters.FixedTime, requestParameters.AllDay, requestParameters.RepeatType, requestParameters.Interval, requestParameters.Sunday, requestParameters.Monday, requestParameters.Tuesday, requestParameters.Wednesday, requestParameters.Thursday, requestParameters.Friday, requestParameters.Saturday, requestParameters.MonthlyType, requestParameters.Dates, requestParameters.MonthOrdinal, requestParameters.WeekDay, requestParameters.EndRepeatType, requestParameters.EndRepeatDate, requestParameters.NumOccurrences, requestParameters.priority, requestParameters.customColor, requestParameters.calendarId, requestParameters.timeProfileId, requestParameters.tagIds, requestParameters.Location, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes multiple items or instances
     * @param {ItemApiApiItemMultipleDeletePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public apiItemMultipleDeletePost(requestParameters: ItemApiApiItemMultipleDeletePostRequest, options?: RawAxiosRequestConfig) {
        return ItemApiFp(this.configuration).apiItemMultipleDeletePost(requestParameters.serializedItemIdToInstanceIdsDict, requestParameters.deleteType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Searches for items based on a query string and other filters.
     * @param {ItemApiApiItemSearchGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemApi
     */
    public apiItemSearchGet(requestParameters: ItemApiApiItemSearchGetRequest, options?: RawAxiosRequestConfig) {
        return ItemApiFp(this.configuration).apiItemSearchGet(requestParameters.query, requestParameters.searchCompletedTasks, requestParameters.getItemsAfterCursor, requestParameters.takeFirst, requestParameters.batchSize, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ScheduleApi - axios parameter creator
 * @export
 */
export const ScheduleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Retrieves an AntiForgeryToken
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiScheduleAntiForgeryTokenGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/Schedule/AntiForgeryToken`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication csrfTokenHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-csrf-token", configuration)

            // authentication cookieAuthAntiforgery required

            // authentication cookieAuthIdentity required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the schedule items
         * @param {ApiScheduleGetScheduleGetScheduleViewTypeEnum} scheduleViewType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiScheduleGetScheduleGet: async (scheduleViewType: ApiScheduleGetScheduleGetScheduleViewTypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleViewType' is not null or undefined
            assertParamExists('apiScheduleGetScheduleGet', 'scheduleViewType', scheduleViewType)
            const localVarPath = `/api/Schedule/GetSchedule`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication csrfTokenHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-csrf-token", configuration)

            // authentication cookieAuthAntiforgery required

            // authentication cookieAuthIdentity required

            if (scheduleViewType !== undefined) {
                localVarQueryParameter['scheduleViewType'] = scheduleViewType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets ToDo list content
         * @param {ApiScheduleGetToDoListContentGetToDoListTypeEnum} toDoListType 
         * @param {number} [calendarFilterId] 
         * @param {number} [tagFilterId] 
         * @param {boolean} [isMissingDeadlineFilterOn] 
         * @param {boolean} [getItemsAfterCursor] 
         * @param {boolean} [takeFirst] 
         * @param {number} [batchSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiScheduleGetToDoListContentGet: async (toDoListType: ApiScheduleGetToDoListContentGetToDoListTypeEnum, calendarFilterId?: number, tagFilterId?: number, isMissingDeadlineFilterOn?: boolean, getItemsAfterCursor?: boolean, takeFirst?: boolean, batchSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'toDoListType' is not null or undefined
            assertParamExists('apiScheduleGetToDoListContentGet', 'toDoListType', toDoListType)
            const localVarPath = `/api/Schedule/GetToDoListContent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication csrfTokenHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-csrf-token", configuration)

            // authentication cookieAuthAntiforgery required

            // authentication cookieAuthIdentity required

            if (toDoListType !== undefined) {
                localVarQueryParameter['toDoListType'] = toDoListType;
            }

            if (calendarFilterId !== undefined) {
                localVarQueryParameter['calendarFilterId'] = calendarFilterId;
            }

            if (tagFilterId !== undefined) {
                localVarQueryParameter['tagFilterId'] = tagFilterId;
            }

            if (isMissingDeadlineFilterOn !== undefined) {
                localVarQueryParameter['isMissingDeadlineFilterOn'] = isMissingDeadlineFilterOn;
            }

            if (getItemsAfterCursor !== undefined) {
                localVarQueryParameter['getItemsAfterCursor'] = getItemsAfterCursor;
            }

            if (takeFirst !== undefined) {
                localVarQueryParameter['takeFirst'] = takeFirst;
            }

            if (batchSize !== undefined) {
                localVarQueryParameter['batchSize'] = batchSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets updates for various entities based on last known versions
         * @param {string} [Items] 
         * @param {string} [Calendars] 
         * @param {string} [Subscription] 
         * @param {string} [Inbox] 
         * @param {string} [ItemSettings] 
         * @param {string} [Tags] 
         * @param {string} [UserSettings] 
         * @param {string} [TimeProfiles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiScheduleGetUpdatesGet: async (Items?: string, Calendars?: string, Subscription?: string, Inbox?: string, ItemSettings?: string, Tags?: string, UserSettings?: string, TimeProfiles?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/Schedule/GetUpdates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication csrfTokenHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-csrf-token", configuration)

            // authentication cookieAuthAntiforgery required

            // authentication cookieAuthIdentity required

            if (Items !== undefined) {
                localVarQueryParameter['Items'] = (Items as any instanceof Date) ?
                    (Items as any).toISOString() :
                    Items;
            }

            if (Calendars !== undefined) {
                localVarQueryParameter['Calendars'] = (Calendars as any instanceof Date) ?
                    (Calendars as any).toISOString() :
                    Calendars;
            }

            if (Subscription !== undefined) {
                localVarQueryParameter['Subscription'] = (Subscription as any instanceof Date) ?
                    (Subscription as any).toISOString() :
                    Subscription;
            }

            if (Inbox !== undefined) {
                localVarQueryParameter['Inbox'] = (Inbox as any instanceof Date) ?
                    (Inbox as any).toISOString() :
                    Inbox;
            }

            if (ItemSettings !== undefined) {
                localVarQueryParameter['ItemSettings'] = (ItemSettings as any instanceof Date) ?
                    (ItemSettings as any).toISOString() :
                    ItemSettings;
            }

            if (Tags !== undefined) {
                localVarQueryParameter['Tags'] = (Tags as any instanceof Date) ?
                    (Tags as any).toISOString() :
                    Tags;
            }

            if (UserSettings !== undefined) {
                localVarQueryParameter['UserSettings'] = (UserSettings as any instanceof Date) ?
                    (UserSettings as any).toISOString() :
                    UserSettings;
            }

            if (TimeProfiles !== undefined) {
                localVarQueryParameter['TimeProfiles'] = (TimeProfiles as any instanceof Date) ?
                    (TimeProfiles as any).toISOString() :
                    TimeProfiles;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets initial data for the schedule view
         * @param {string} clientTimeZone 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiScheduleInitialDataGet: async (clientTimeZone: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientTimeZone' is not null or undefined
            assertParamExists('apiScheduleInitialDataGet', 'clientTimeZone', clientTimeZone)
            const localVarPath = `/api/Schedule/InitialData`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication csrfTokenHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-csrf-token", configuration)

            // authentication cookieAuthAntiforgery required

            // authentication cookieAuthIdentity required

            if (clientTimeZone !== undefined) {
                localVarQueryParameter['clientTimeZone'] = clientTimeZone;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Checks if the current user is authenticated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiScheduleIsAuthenticatedGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/schedule/isAuthenticated`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication csrfTokenHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-csrf-token", configuration)

            // authentication cookieAuthAntiforgery required

            // authentication cookieAuthIdentity required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Logs an event to Amplitude
         * @param {string} eventName 
         * @param {string} date 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiScheduleLogAmplitudeEventPost: async (eventName: string, date: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventName' is not null or undefined
            assertParamExists('apiScheduleLogAmplitudeEventPost', 'eventName', eventName)
            // verify required parameter 'date' is not null or undefined
            assertParamExists('apiScheduleLogAmplitudeEventPost', 'date', date)
            const localVarPath = `/api/Schedule/LogAmplitudeEvent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication csrfTokenHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-csrf-token", configuration)

            // authentication cookieAuthAntiforgery required

            // authentication cookieAuthIdentity required


            if (eventName !== undefined) { 
                localVarFormParams.append('eventName', eventName as any);
            }
    
            if (date !== undefined) { 
                localVarFormParams.append('date', date as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Recalculates the schedule
         * @param {string} contentType 
         * @param {string} startDate 
         * @param {boolean} isResolutionCenterOpen 
         * @param {boolean} force 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiScheduleRecalculatePost: async (contentType: string, startDate: string, isResolutionCenterOpen: boolean, force: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contentType' is not null or undefined
            assertParamExists('apiScheduleRecalculatePost', 'contentType', contentType)
            // verify required parameter 'startDate' is not null or undefined
            assertParamExists('apiScheduleRecalculatePost', 'startDate', startDate)
            // verify required parameter 'isResolutionCenterOpen' is not null or undefined
            assertParamExists('apiScheduleRecalculatePost', 'isResolutionCenterOpen', isResolutionCenterOpen)
            // verify required parameter 'force' is not null or undefined
            assertParamExists('apiScheduleRecalculatePost', 'force', force)
            const localVarPath = `/api/Schedule/Recalculate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication csrfTokenHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-csrf-token", configuration)

            // authentication cookieAuthAntiforgery required

            // authentication cookieAuthIdentity required


            if (contentType !== undefined) { 
                localVarFormParams.append('contentType', contentType as any);
            }
    
            if (startDate !== undefined) { 
                localVarFormParams.append('startDate', startDate as any);
            }
    
            if (isResolutionCenterOpen !== undefined) { 
                localVarFormParams.append('isResolutionCenterOpen', String(isResolutionCenterOpen) as any);
            }
    
            if (force !== undefined) { 
                localVarFormParams.append('force', String(force) as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ScheduleApi - functional programming interface
 * @export
 */
export const ScheduleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ScheduleApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Retrieves an AntiForgeryToken
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiScheduleAntiForgeryTokenGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiScheduleAntiForgeryTokenGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScheduleApi.apiScheduleAntiForgeryTokenGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Gets the schedule items
         * @param {ApiScheduleGetScheduleGetScheduleViewTypeEnum} scheduleViewType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiScheduleGetScheduleGet(scheduleViewType: ApiScheduleGetScheduleGetScheduleViewTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetScheduleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiScheduleGetScheduleGet(scheduleViewType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScheduleApi.apiScheduleGetScheduleGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Gets ToDo list content
         * @param {ApiScheduleGetToDoListContentGetToDoListTypeEnum} toDoListType 
         * @param {number} [calendarFilterId] 
         * @param {number} [tagFilterId] 
         * @param {boolean} [isMissingDeadlineFilterOn] 
         * @param {boolean} [getItemsAfterCursor] 
         * @param {boolean} [takeFirst] 
         * @param {number} [batchSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiScheduleGetToDoListContentGet(toDoListType: ApiScheduleGetToDoListContentGetToDoListTypeEnum, calendarFilterId?: number, tagFilterId?: number, isMissingDeadlineFilterOn?: boolean, getItemsAfterCursor?: boolean, takeFirst?: boolean, batchSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetToDoListContentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiScheduleGetToDoListContentGet(toDoListType, calendarFilterId, tagFilterId, isMissingDeadlineFilterOn, getItemsAfterCursor, takeFirst, batchSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScheduleApi.apiScheduleGetToDoListContentGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Gets updates for various entities based on last known versions
         * @param {string} [Items] 
         * @param {string} [Calendars] 
         * @param {string} [Subscription] 
         * @param {string} [Inbox] 
         * @param {string} [ItemSettings] 
         * @param {string} [Tags] 
         * @param {string} [UserSettings] 
         * @param {string} [TimeProfiles] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiScheduleGetUpdatesGet(Items?: string, Calendars?: string, Subscription?: string, Inbox?: string, ItemSettings?: string, Tags?: string, UserSettings?: string, TimeProfiles?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUpdatesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiScheduleGetUpdatesGet(Items, Calendars, Subscription, Inbox, ItemSettings, Tags, UserSettings, TimeProfiles, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScheduleApi.apiScheduleGetUpdatesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Gets initial data for the schedule view
         * @param {string} clientTimeZone 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiScheduleInitialDataGet(clientTimeZone: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InitialDataResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiScheduleInitialDataGet(clientTimeZone, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScheduleApi.apiScheduleInitialDataGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Checks if the current user is authenticated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiScheduleIsAuthenticatedGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IsAuthenticatedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiScheduleIsAuthenticatedGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScheduleApi.apiScheduleIsAuthenticatedGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Logs an event to Amplitude
         * @param {string} eventName 
         * @param {string} date 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiScheduleLogAmplitudeEventPost(eventName: string, date: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiScheduleLogAmplitudeEventPost(eventName, date, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScheduleApi.apiScheduleLogAmplitudeEventPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Recalculates the schedule
         * @param {string} contentType 
         * @param {string} startDate 
         * @param {boolean} isResolutionCenterOpen 
         * @param {boolean} force 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiScheduleRecalculatePost(contentType: string, startDate: string, isResolutionCenterOpen: boolean, force: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecalculateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiScheduleRecalculatePost(contentType, startDate, isResolutionCenterOpen, force, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ScheduleApi.apiScheduleRecalculatePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ScheduleApi - factory interface
 * @export
 */
export const ScheduleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ScheduleApiFp(configuration)
    return {
        /**
         * 
         * @summary Retrieves an AntiForgeryToken
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiScheduleAntiForgeryTokenGet(options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.apiScheduleAntiForgeryTokenGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the schedule items
         * @param {ScheduleApiApiScheduleGetScheduleGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiScheduleGetScheduleGet(requestParameters: ScheduleApiApiScheduleGetScheduleGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetScheduleResponse> {
            return localVarFp.apiScheduleGetScheduleGet(requestParameters.scheduleViewType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets ToDo list content
         * @param {ScheduleApiApiScheduleGetToDoListContentGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiScheduleGetToDoListContentGet(requestParameters: ScheduleApiApiScheduleGetToDoListContentGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<GetToDoListContentResponse> {
            return localVarFp.apiScheduleGetToDoListContentGet(requestParameters.toDoListType, requestParameters.calendarFilterId, requestParameters.tagFilterId, requestParameters.isMissingDeadlineFilterOn, requestParameters.getItemsAfterCursor, requestParameters.takeFirst, requestParameters.batchSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets updates for various entities based on last known versions
         * @param {ScheduleApiApiScheduleGetUpdatesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiScheduleGetUpdatesGet(requestParameters: ScheduleApiApiScheduleGetUpdatesGetRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<GetUpdatesResponse> {
            return localVarFp.apiScheduleGetUpdatesGet(requestParameters.Items, requestParameters.Calendars, requestParameters.Subscription, requestParameters.Inbox, requestParameters.ItemSettings, requestParameters.Tags, requestParameters.UserSettings, requestParameters.TimeProfiles, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets initial data for the schedule view
         * @param {ScheduleApiApiScheduleInitialDataGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiScheduleInitialDataGet(requestParameters: ScheduleApiApiScheduleInitialDataGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<InitialDataResponse> {
            return localVarFp.apiScheduleInitialDataGet(requestParameters.clientTimeZone, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Checks if the current user is authenticated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiScheduleIsAuthenticatedGet(options?: RawAxiosRequestConfig): AxiosPromise<IsAuthenticatedResponse> {
            return localVarFp.apiScheduleIsAuthenticatedGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Logs an event to Amplitude
         * @param {ScheduleApiApiScheduleLogAmplitudeEventPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiScheduleLogAmplitudeEventPost(requestParameters: ScheduleApiApiScheduleLogAmplitudeEventPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.apiScheduleLogAmplitudeEventPost(requestParameters.eventName, requestParameters.date, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Recalculates the schedule
         * @param {ScheduleApiApiScheduleRecalculatePostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiScheduleRecalculatePost(requestParameters: ScheduleApiApiScheduleRecalculatePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<RecalculateResponse> {
            return localVarFp.apiScheduleRecalculatePost(requestParameters.contentType, requestParameters.startDate, requestParameters.isResolutionCenterOpen, requestParameters.force, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for apiScheduleGetScheduleGet operation in ScheduleApi.
 * @export
 * @interface ScheduleApiApiScheduleGetScheduleGetRequest
 */
export interface ScheduleApiApiScheduleGetScheduleGetRequest {
    /**
     * 
     * @type {'7days' | '1day' | 'list'}
     * @memberof ScheduleApiApiScheduleGetScheduleGet
     */
    readonly scheduleViewType: ApiScheduleGetScheduleGetScheduleViewTypeEnum
}

/**
 * Request parameters for apiScheduleGetToDoListContentGet operation in ScheduleApi.
 * @export
 * @interface ScheduleApiApiScheduleGetToDoListContentGetRequest
 */
export interface ScheduleApiApiScheduleGetToDoListContentGetRequest {
    /**
     * 
     * @type {'ToDo' | 'Done'}
     * @memberof ScheduleApiApiScheduleGetToDoListContentGet
     */
    readonly toDoListType: ApiScheduleGetToDoListContentGetToDoListTypeEnum

    /**
     * 
     * @type {number}
     * @memberof ScheduleApiApiScheduleGetToDoListContentGet
     */
    readonly calendarFilterId?: number

    /**
     * 
     * @type {number}
     * @memberof ScheduleApiApiScheduleGetToDoListContentGet
     */
    readonly tagFilterId?: number

    /**
     * 
     * @type {boolean}
     * @memberof ScheduleApiApiScheduleGetToDoListContentGet
     */
    readonly isMissingDeadlineFilterOn?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof ScheduleApiApiScheduleGetToDoListContentGet
     */
    readonly getItemsAfterCursor?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof ScheduleApiApiScheduleGetToDoListContentGet
     */
    readonly takeFirst?: boolean

    /**
     * 
     * @type {number}
     * @memberof ScheduleApiApiScheduleGetToDoListContentGet
     */
    readonly batchSize?: number
}

/**
 * Request parameters for apiScheduleGetUpdatesGet operation in ScheduleApi.
 * @export
 * @interface ScheduleApiApiScheduleGetUpdatesGetRequest
 */
export interface ScheduleApiApiScheduleGetUpdatesGetRequest {
    /**
     * 
     * @type {string}
     * @memberof ScheduleApiApiScheduleGetUpdatesGet
     */
    readonly Items?: string

    /**
     * 
     * @type {string}
     * @memberof ScheduleApiApiScheduleGetUpdatesGet
     */
    readonly Calendars?: string

    /**
     * 
     * @type {string}
     * @memberof ScheduleApiApiScheduleGetUpdatesGet
     */
    readonly Subscription?: string

    /**
     * 
     * @type {string}
     * @memberof ScheduleApiApiScheduleGetUpdatesGet
     */
    readonly Inbox?: string

    /**
     * 
     * @type {string}
     * @memberof ScheduleApiApiScheduleGetUpdatesGet
     */
    readonly ItemSettings?: string

    /**
     * 
     * @type {string}
     * @memberof ScheduleApiApiScheduleGetUpdatesGet
     */
    readonly Tags?: string

    /**
     * 
     * @type {string}
     * @memberof ScheduleApiApiScheduleGetUpdatesGet
     */
    readonly UserSettings?: string

    /**
     * 
     * @type {string}
     * @memberof ScheduleApiApiScheduleGetUpdatesGet
     */
    readonly TimeProfiles?: string
}

/**
 * Request parameters for apiScheduleInitialDataGet operation in ScheduleApi.
 * @export
 * @interface ScheduleApiApiScheduleInitialDataGetRequest
 */
export interface ScheduleApiApiScheduleInitialDataGetRequest {
    /**
     * 
     * @type {string}
     * @memberof ScheduleApiApiScheduleInitialDataGet
     */
    readonly clientTimeZone: string
}

/**
 * Request parameters for apiScheduleLogAmplitudeEventPost operation in ScheduleApi.
 * @export
 * @interface ScheduleApiApiScheduleLogAmplitudeEventPostRequest
 */
export interface ScheduleApiApiScheduleLogAmplitudeEventPostRequest {
    /**
     * 
     * @type {string}
     * @memberof ScheduleApiApiScheduleLogAmplitudeEventPost
     */
    readonly eventName: string

    /**
     * 
     * @type {string}
     * @memberof ScheduleApiApiScheduleLogAmplitudeEventPost
     */
    readonly date: string
}

/**
 * Request parameters for apiScheduleRecalculatePost operation in ScheduleApi.
 * @export
 * @interface ScheduleApiApiScheduleRecalculatePostRequest
 */
export interface ScheduleApiApiScheduleRecalculatePostRequest {
    /**
     * 
     * @type {string}
     * @memberof ScheduleApiApiScheduleRecalculatePost
     */
    readonly contentType: string

    /**
     * 
     * @type {string}
     * @memberof ScheduleApiApiScheduleRecalculatePost
     */
    readonly startDate: string

    /**
     * 
     * @type {boolean}
     * @memberof ScheduleApiApiScheduleRecalculatePost
     */
    readonly isResolutionCenterOpen: boolean

    /**
     * 
     * @type {boolean}
     * @memberof ScheduleApiApiScheduleRecalculatePost
     */
    readonly force: boolean
}

/**
 * ScheduleApi - object-oriented interface
 * @export
 * @class ScheduleApi
 * @extends {BaseAPI}
 */
export class ScheduleApi extends BaseAPI {
    /**
     * 
     * @summary Retrieves an AntiForgeryToken
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduleApi
     */
    public apiScheduleAntiForgeryTokenGet(options?: RawAxiosRequestConfig) {
        return ScheduleApiFp(this.configuration).apiScheduleAntiForgeryTokenGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the schedule items
     * @param {ScheduleApiApiScheduleGetScheduleGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduleApi
     */
    public apiScheduleGetScheduleGet(requestParameters: ScheduleApiApiScheduleGetScheduleGetRequest, options?: RawAxiosRequestConfig) {
        return ScheduleApiFp(this.configuration).apiScheduleGetScheduleGet(requestParameters.scheduleViewType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets ToDo list content
     * @param {ScheduleApiApiScheduleGetToDoListContentGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduleApi
     */
    public apiScheduleGetToDoListContentGet(requestParameters: ScheduleApiApiScheduleGetToDoListContentGetRequest, options?: RawAxiosRequestConfig) {
        return ScheduleApiFp(this.configuration).apiScheduleGetToDoListContentGet(requestParameters.toDoListType, requestParameters.calendarFilterId, requestParameters.tagFilterId, requestParameters.isMissingDeadlineFilterOn, requestParameters.getItemsAfterCursor, requestParameters.takeFirst, requestParameters.batchSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets updates for various entities based on last known versions
     * @param {ScheduleApiApiScheduleGetUpdatesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduleApi
     */
    public apiScheduleGetUpdatesGet(requestParameters: ScheduleApiApiScheduleGetUpdatesGetRequest = {}, options?: RawAxiosRequestConfig) {
        return ScheduleApiFp(this.configuration).apiScheduleGetUpdatesGet(requestParameters.Items, requestParameters.Calendars, requestParameters.Subscription, requestParameters.Inbox, requestParameters.ItemSettings, requestParameters.Tags, requestParameters.UserSettings, requestParameters.TimeProfiles, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets initial data for the schedule view
     * @param {ScheduleApiApiScheduleInitialDataGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduleApi
     */
    public apiScheduleInitialDataGet(requestParameters: ScheduleApiApiScheduleInitialDataGetRequest, options?: RawAxiosRequestConfig) {
        return ScheduleApiFp(this.configuration).apiScheduleInitialDataGet(requestParameters.clientTimeZone, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Checks if the current user is authenticated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduleApi
     */
    public apiScheduleIsAuthenticatedGet(options?: RawAxiosRequestConfig) {
        return ScheduleApiFp(this.configuration).apiScheduleIsAuthenticatedGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Logs an event to Amplitude
     * @param {ScheduleApiApiScheduleLogAmplitudeEventPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduleApi
     */
    public apiScheduleLogAmplitudeEventPost(requestParameters: ScheduleApiApiScheduleLogAmplitudeEventPostRequest, options?: RawAxiosRequestConfig) {
        return ScheduleApiFp(this.configuration).apiScheduleLogAmplitudeEventPost(requestParameters.eventName, requestParameters.date, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Recalculates the schedule
     * @param {ScheduleApiApiScheduleRecalculatePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScheduleApi
     */
    public apiScheduleRecalculatePost(requestParameters: ScheduleApiApiScheduleRecalculatePostRequest, options?: RawAxiosRequestConfig) {
        return ScheduleApiFp(this.configuration).apiScheduleRecalculatePost(requestParameters.contentType, requestParameters.startDate, requestParameters.isResolutionCenterOpen, requestParameters.force, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ApiScheduleGetScheduleGetScheduleViewTypeEnum = {
    _7days: '7days',
    _1day: '1day',
    List: 'list'
} as const;
export type ApiScheduleGetScheduleGetScheduleViewTypeEnum = typeof ApiScheduleGetScheduleGetScheduleViewTypeEnum[keyof typeof ApiScheduleGetScheduleGetScheduleViewTypeEnum];
/**
 * @export
 */
export const ApiScheduleGetToDoListContentGetToDoListTypeEnum = {
    ToDo: 'ToDo',
    Done: 'Done'
} as const;
export type ApiScheduleGetToDoListContentGetToDoListTypeEnum = typeof ApiScheduleGetToDoListContentGetToDoListTypeEnum[keyof typeof ApiScheduleGetToDoListContentGetToDoListTypeEnum];


/**
 * TagApi - axios parameter creator
 * @export
 */
export const TagApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets the list of tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTagListGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/tag/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication csrfTokenHeader required
            await setApiKeyToObject(localVarHeaderParameter, "x-csrf-token", configuration)

            // authentication cookieAuthAntiforgery required

            // authentication cookieAuthIdentity required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagApi - functional programming interface
 * @export
 */
export const TagApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TagApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Gets the list of tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiTagListGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TagListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiTagListGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TagApi.apiTagListGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TagApi - factory interface
 * @export
 */
export const TagApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TagApiFp(configuration)
    return {
        /**
         * 
         * @summary Gets the list of tags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTagListGet(options?: RawAxiosRequestConfig): AxiosPromise<TagListResponse> {
            return localVarFp.apiTagListGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TagApi - object-oriented interface
 * @export
 * @class TagApi
 * @extends {BaseAPI}
 */
export class TagApi extends BaseAPI {
    /**
     * 
     * @summary Gets the list of tags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApi
     */
    public apiTagListGet(options?: RawAxiosRequestConfig) {
        return TagApiFp(this.configuration).apiTagListGet(options).then((request) => request(this.axios, this.basePath));
    }
}



