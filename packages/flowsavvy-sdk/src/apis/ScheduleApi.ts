/* tslint:disable */
/* eslint-disable */
/**
 * FlowSavvy API
 * API for managing tasks, events, and schedules on FlowSavvy.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  GetScheduleResponse,
  GetToDoListContentResponse,
  GetUpdatesResponse,
  InitialDataResponse,
  IsAuthenticatedResponse,
  RecalculateResponse,
} from '../models/index';
import {
    GetScheduleResponseFromJSON,
    GetScheduleResponseToJSON,
    GetToDoListContentResponseFromJSON,
    GetToDoListContentResponseToJSON,
    GetUpdatesResponseFromJSON,
    GetUpdatesResponseToJSON,
    InitialDataResponseFromJSON,
    InitialDataResponseToJSON,
    IsAuthenticatedResponseFromJSON,
    IsAuthenticatedResponseToJSON,
    RecalculateResponseFromJSON,
    RecalculateResponseToJSON,
} from '../models/index';

export interface ApiScheduleGetScheduleGetRequest {
    scheduleViewType: ApiScheduleGetScheduleGetScheduleViewTypeEnum;
}

export interface ApiScheduleGetToDoListContentGetRequest {
    toDoListType: ApiScheduleGetToDoListContentGetToDoListTypeEnum;
    calendarFilterId?: number;
    tagFilterId?: number;
    isMissingDeadlineFilterOn?: boolean;
    getItemsAfterCursor?: boolean;
    takeFirst?: boolean;
    batchSize?: number;
}

export interface ApiScheduleGetUpdatesGetRequest {
    items?: Date;
    calendars?: Date;
    subscription?: Date;
    inbox?: Date;
    itemSettings?: Date;
    tags?: Date;
    userSettings?: Date;
    timeProfiles?: Date;
}

export interface ApiScheduleInitialDataGetRequest {
    clientTimeZone: string;
}

export interface ApiScheduleLogAmplitudeEventPostRequest {
    eventName: string;
    date: Date;
}

export interface ApiScheduleRecalculatePostRequest {
    contentType: string;
    startDate: Date;
    isResolutionCenterOpen: boolean;
    force: boolean;
}

/**
 * 
 */
export class ScheduleApi extends runtime.BaseAPI {

    /**
     * Retrieves an AntiForgeryToken
     */
    async apiScheduleAntiForgeryTokenGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<string>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-csrf-token"] = await this.configuration.apiKey("x-csrf-token"); // csrfTokenHeader authentication
        }

        const response = await this.request({
            path: `/api/Schedule/AntiForgeryToken`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<string>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Retrieves an AntiForgeryToken
     */
    async apiScheduleAntiForgeryTokenGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<string> {
        const response = await this.apiScheduleAntiForgeryTokenGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Gets the schedule items
     */
    async apiScheduleGetScheduleGetRaw(requestParameters: ApiScheduleGetScheduleGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetScheduleResponse>> {
        if (requestParameters['scheduleViewType'] == null) {
            throw new runtime.RequiredError(
                'scheduleViewType',
                'Required parameter "scheduleViewType" was null or undefined when calling apiScheduleGetScheduleGet().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['scheduleViewType'] != null) {
            queryParameters['scheduleViewType'] = requestParameters['scheduleViewType'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-csrf-token"] = await this.configuration.apiKey("x-csrf-token"); // csrfTokenHeader authentication
        }

        const response = await this.request({
            path: `/api/Schedule/GetSchedule`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetScheduleResponseFromJSON(jsonValue));
    }

    /**
     * Gets the schedule items
     */
    async apiScheduleGetScheduleGet(requestParameters: ApiScheduleGetScheduleGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetScheduleResponse> {
        const response = await this.apiScheduleGetScheduleGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Gets ToDo list content
     */
    async apiScheduleGetToDoListContentGetRaw(requestParameters: ApiScheduleGetToDoListContentGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetToDoListContentResponse>> {
        if (requestParameters['toDoListType'] == null) {
            throw new runtime.RequiredError(
                'toDoListType',
                'Required parameter "toDoListType" was null or undefined when calling apiScheduleGetToDoListContentGet().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['toDoListType'] != null) {
            queryParameters['toDoListType'] = requestParameters['toDoListType'];
        }

        if (requestParameters['calendarFilterId'] != null) {
            queryParameters['calendarFilterId'] = requestParameters['calendarFilterId'];
        }

        if (requestParameters['tagFilterId'] != null) {
            queryParameters['tagFilterId'] = requestParameters['tagFilterId'];
        }

        if (requestParameters['isMissingDeadlineFilterOn'] != null) {
            queryParameters['isMissingDeadlineFilterOn'] = requestParameters['isMissingDeadlineFilterOn'];
        }

        if (requestParameters['getItemsAfterCursor'] != null) {
            queryParameters['getItemsAfterCursor'] = requestParameters['getItemsAfterCursor'];
        }

        if (requestParameters['takeFirst'] != null) {
            queryParameters['takeFirst'] = requestParameters['takeFirst'];
        }

        if (requestParameters['batchSize'] != null) {
            queryParameters['batchSize'] = requestParameters['batchSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-csrf-token"] = await this.configuration.apiKey("x-csrf-token"); // csrfTokenHeader authentication
        }

        const response = await this.request({
            path: `/api/Schedule/GetToDoListContent`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetToDoListContentResponseFromJSON(jsonValue));
    }

    /**
     * Gets ToDo list content
     */
    async apiScheduleGetToDoListContentGet(requestParameters: ApiScheduleGetToDoListContentGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetToDoListContentResponse> {
        const response = await this.apiScheduleGetToDoListContentGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Gets updates for various entities based on last known versions
     */
    async apiScheduleGetUpdatesGetRaw(requestParameters: ApiScheduleGetUpdatesGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetUpdatesResponse>> {
        const queryParameters: any = {};

        if (requestParameters['items'] != null) {
            queryParameters['Items'] = (requestParameters['items'] as any).toISOString();
        }

        if (requestParameters['calendars'] != null) {
            queryParameters['Calendars'] = (requestParameters['calendars'] as any).toISOString();
        }

        if (requestParameters['subscription'] != null) {
            queryParameters['Subscription'] = (requestParameters['subscription'] as any).toISOString();
        }

        if (requestParameters['inbox'] != null) {
            queryParameters['Inbox'] = (requestParameters['inbox'] as any).toISOString();
        }

        if (requestParameters['itemSettings'] != null) {
            queryParameters['ItemSettings'] = (requestParameters['itemSettings'] as any).toISOString();
        }

        if (requestParameters['tags'] != null) {
            queryParameters['Tags'] = (requestParameters['tags'] as any).toISOString();
        }

        if (requestParameters['userSettings'] != null) {
            queryParameters['UserSettings'] = (requestParameters['userSettings'] as any).toISOString();
        }

        if (requestParameters['timeProfiles'] != null) {
            queryParameters['TimeProfiles'] = (requestParameters['timeProfiles'] as any).toISOString();
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-csrf-token"] = await this.configuration.apiKey("x-csrf-token"); // csrfTokenHeader authentication
        }

        const response = await this.request({
            path: `/api/Schedule/GetUpdates`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetUpdatesResponseFromJSON(jsonValue));
    }

    /**
     * Gets updates for various entities based on last known versions
     */
    async apiScheduleGetUpdatesGet(requestParameters: ApiScheduleGetUpdatesGetRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetUpdatesResponse> {
        const response = await this.apiScheduleGetUpdatesGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Gets initial data for the schedule view
     */
    async apiScheduleInitialDataGetRaw(requestParameters: ApiScheduleInitialDataGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<InitialDataResponse>> {
        if (requestParameters['clientTimeZone'] == null) {
            throw new runtime.RequiredError(
                'clientTimeZone',
                'Required parameter "clientTimeZone" was null or undefined when calling apiScheduleInitialDataGet().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['clientTimeZone'] != null) {
            queryParameters['clientTimeZone'] = requestParameters['clientTimeZone'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-csrf-token"] = await this.configuration.apiKey("x-csrf-token"); // csrfTokenHeader authentication
        }

        const response = await this.request({
            path: `/api/Schedule/InitialData`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => InitialDataResponseFromJSON(jsonValue));
    }

    /**
     * Gets initial data for the schedule view
     */
    async apiScheduleInitialDataGet(requestParameters: ApiScheduleInitialDataGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<InitialDataResponse> {
        const response = await this.apiScheduleInitialDataGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Checks if the current user is authenticated
     */
    async apiScheduleIsAuthenticatedGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<IsAuthenticatedResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-csrf-token"] = await this.configuration.apiKey("x-csrf-token"); // csrfTokenHeader authentication
        }

        const response = await this.request({
            path: `/api/schedule/isAuthenticated`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IsAuthenticatedResponseFromJSON(jsonValue));
    }

    /**
     * Checks if the current user is authenticated
     */
    async apiScheduleIsAuthenticatedGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<IsAuthenticatedResponse> {
        const response = await this.apiScheduleIsAuthenticatedGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Logs an event to Amplitude
     */
    async apiScheduleLogAmplitudeEventPostRaw(requestParameters: ApiScheduleLogAmplitudeEventPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['eventName'] == null) {
            throw new runtime.RequiredError(
                'eventName',
                'Required parameter "eventName" was null or undefined when calling apiScheduleLogAmplitudeEventPost().'
            );
        }

        if (requestParameters['date'] == null) {
            throw new runtime.RequiredError(
                'date',
                'Required parameter "date" was null or undefined when calling apiScheduleLogAmplitudeEventPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-csrf-token"] = await this.configuration.apiKey("x-csrf-token"); // csrfTokenHeader authentication
        }

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['eventName'] != null) {
            formParams.append('eventName', requestParameters['eventName'] as any);
        }

        if (requestParameters['date'] != null) {
            formParams.append('date', (requestParameters['date'] as any).toISOString());
        }

        const response = await this.request({
            path: `/api/Schedule/LogAmplitudeEvent`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Logs an event to Amplitude
     */
    async apiScheduleLogAmplitudeEventPost(requestParameters: ApiScheduleLogAmplitudeEventPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.apiScheduleLogAmplitudeEventPostRaw(requestParameters, initOverrides);
    }

    /**
     * Recalculates the schedule
     */
    async apiScheduleRecalculatePostRaw(requestParameters: ApiScheduleRecalculatePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RecalculateResponse>> {
        if (requestParameters['contentType'] == null) {
            throw new runtime.RequiredError(
                'contentType',
                'Required parameter "contentType" was null or undefined when calling apiScheduleRecalculatePost().'
            );
        }

        if (requestParameters['startDate'] == null) {
            throw new runtime.RequiredError(
                'startDate',
                'Required parameter "startDate" was null or undefined when calling apiScheduleRecalculatePost().'
            );
        }

        if (requestParameters['isResolutionCenterOpen'] == null) {
            throw new runtime.RequiredError(
                'isResolutionCenterOpen',
                'Required parameter "isResolutionCenterOpen" was null or undefined when calling apiScheduleRecalculatePost().'
            );
        }

        if (requestParameters['force'] == null) {
            throw new runtime.RequiredError(
                'force',
                'Required parameter "force" was null or undefined when calling apiScheduleRecalculatePost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-csrf-token"] = await this.configuration.apiKey("x-csrf-token"); // csrfTokenHeader authentication
        }

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['contentType'] != null) {
            formParams.append('contentType', requestParameters['contentType'] as any);
        }

        if (requestParameters['startDate'] != null) {
            formParams.append('startDate', requestParameters['startDate'] as any);
        }

        if (requestParameters['isResolutionCenterOpen'] != null) {
            formParams.append('isResolutionCenterOpen', requestParameters['isResolutionCenterOpen'] as any);
        }

        if (requestParameters['force'] != null) {
            formParams.append('force', requestParameters['force'] as any);
        }

        const response = await this.request({
            path: `/api/Schedule/Recalculate`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RecalculateResponseFromJSON(jsonValue));
    }

    /**
     * Recalculates the schedule
     */
    async apiScheduleRecalculatePost(requestParameters: ApiScheduleRecalculatePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RecalculateResponse> {
        const response = await this.apiScheduleRecalculatePostRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const ApiScheduleGetScheduleGetScheduleViewTypeEnum = {
    _7days: '7days',
    _1day: '1day',
    List: 'list'
} as const;
export type ApiScheduleGetScheduleGetScheduleViewTypeEnum = typeof ApiScheduleGetScheduleGetScheduleViewTypeEnum[keyof typeof ApiScheduleGetScheduleGetScheduleViewTypeEnum];
/**
 * @export
 */
export const ApiScheduleGetToDoListContentGetToDoListTypeEnum = {
    ToDo: 'ToDo',
    Done: 'Done'
} as const;
export type ApiScheduleGetToDoListContentGetToDoListTypeEnum = typeof ApiScheduleGetToDoListContentGetToDoListTypeEnum[keyof typeof ApiScheduleGetToDoListContentGetToDoListTypeEnum];
