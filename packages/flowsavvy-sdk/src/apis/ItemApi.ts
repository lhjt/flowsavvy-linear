/* tslint:disable */
/* eslint-disable */
/**
 * FlowSavvy API
 * API for managing tasks, events, and schedules on FlowSavvy.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  ChangePartialCompleteStatusResponse,
  ItemCreateResponse,
  ItemEditGetDataResponse,
  ItemEditResponse,
  MultipleDeleteResponse,
  SearchResponseWrapper,
} from '../models/index';
import {
    ChangePartialCompleteStatusResponseFromJSON,
    ChangePartialCompleteStatusResponseToJSON,
    ItemCreateResponseFromJSON,
    ItemCreateResponseToJSON,
    ItemEditGetDataResponseFromJSON,
    ItemEditGetDataResponseToJSON,
    ItemEditResponseFromJSON,
    ItemEditResponseToJSON,
    MultipleDeleteResponseFromJSON,
    MultipleDeleteResponseToJSON,
    SearchResponseWrapperFromJSON,
    SearchResponseWrapperToJSON,
} from '../models/index';

export interface ApiItemChangePartialCompleteStatusPostRequest {
    itemId: number;
    instanceId: number;
    scheduleItemId: number;
}

export interface ApiItemCreatePostRequest {
    id?: number;
    instanceID?: number;
    notes?: string;
    dueDateTime?: Date | null;
    startDateTime?: Date;
    endDateTime?: Date;
    dontStartUntil?: Date;
    timeZone?: string;
    isAutoIgnored?: boolean;
    title?: string;
    itemType?: string;
    progressHours?: number;
    progressMinutes?: number;
    minLengthTotalMinutes?: number;
    bufferTimeBeforeHours?: number;
    bufferTimeBeforeMinutes?: number;
    bufferTimeAfterHours?: number;
    bufferTimeAfterMinutes?: number;
    busy?: boolean;
    fixedTime?: boolean;
    allDay?: boolean;
    repeatType?: string;
    interval?: number;
    sunday?: boolean;
    monday?: boolean;
    tuesday?: boolean;
    wednesday?: boolean;
    thursday?: boolean;
    friday?: boolean;
    saturday?: boolean;
    monthlyType?: string;
    dates?: string | null;
    monthOrdinal?: number;
    weekDay?: number;
    endRepeatType?: string;
    endRepeatDate?: Date;
    numOccurrences?: number;
    priority?: number;
    customColor?: string | null;
    calendarId?: number;
    timeProfileId?: number | null;
    tagIds?: string;
    location?: string | null;
}

export interface ApiItemEditGetRequest {
    itemId: number;
    instanceId: number;
}

export interface ApiItemEditPostRequest {
    id: number;
    instanceID?: number;
    notes?: string;
    dueDateTime?: Date | null;
    startDateTime?: Date;
    endDateTime?: Date;
    dontStartUntil?: Date;
    timeZone?: string;
    isAutoIgnored?: boolean;
    title?: string;
    itemType?: string;
    progressHours?: number;
    progressMinutes?: number;
    minLengthTotalMinutes?: number;
    bufferTimeBeforeHours?: number;
    bufferTimeBeforeMinutes?: number;
    bufferTimeAfterHours?: number;
    bufferTimeAfterMinutes?: number;
    busy?: boolean;
    fixedTime?: boolean;
    allDay?: boolean;
    repeatType?: string;
    interval?: number;
    sunday?: boolean;
    monday?: boolean;
    tuesday?: boolean;
    wednesday?: boolean;
    thursday?: boolean;
    friday?: boolean;
    saturday?: boolean;
    monthlyType?: string;
    dates?: string | null;
    monthOrdinal?: number;
    weekDay?: number;
    endRepeatType?: string;
    endRepeatDate?: Date;
    numOccurrences?: number;
    priority?: number;
    customColor?: string | null;
    calendarId?: number;
    timeProfileId?: number | null;
    tagIds?: string;
    location?: string | null;
}

export interface ApiItemMultipleDeletePostRequest {
    serializedItemIdToInstanceIdsDict: string;
    deleteType: string;
}

export interface ApiItemSearchGetRequest {
    query: string;
    searchCompletedTasks: boolean;
    getItemsAfterCursor: boolean;
    takeFirst: boolean;
    batchSize: number;
}

/**
 * 
 */
export class ItemApi extends runtime.BaseAPI {

    /**
     * Changes the partial completion status of an item instance or a specific schedule item.
     */
    async apiItemChangePartialCompleteStatusPostRaw(requestParameters: ApiItemChangePartialCompleteStatusPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ChangePartialCompleteStatusResponse>> {
        if (requestParameters['itemId'] == null) {
            throw new runtime.RequiredError(
                'itemId',
                'Required parameter "itemId" was null or undefined when calling apiItemChangePartialCompleteStatusPost().'
            );
        }

        if (requestParameters['instanceId'] == null) {
            throw new runtime.RequiredError(
                'instanceId',
                'Required parameter "instanceId" was null or undefined when calling apiItemChangePartialCompleteStatusPost().'
            );
        }

        if (requestParameters['scheduleItemId'] == null) {
            throw new runtime.RequiredError(
                'scheduleItemId',
                'Required parameter "scheduleItemId" was null or undefined when calling apiItemChangePartialCompleteStatusPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-csrf-token"] = await this.configuration.apiKey("x-csrf-token"); // csrfTokenHeader authentication
        }

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['itemId'] != null) {
            formParams.append('itemId', requestParameters['itemId'] as any);
        }

        if (requestParameters['instanceId'] != null) {
            formParams.append('instanceId', requestParameters['instanceId'] as any);
        }

        if (requestParameters['scheduleItemId'] != null) {
            formParams.append('scheduleItemId', requestParameters['scheduleItemId'] as any);
        }

        const response = await this.request({
            path: `/api/Item/ChangePartialCompleteStatus`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ChangePartialCompleteStatusResponseFromJSON(jsonValue));
    }

    /**
     * Changes the partial completion status of an item instance or a specific schedule item.
     */
    async apiItemChangePartialCompleteStatusPost(requestParameters: ApiItemChangePartialCompleteStatusPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ChangePartialCompleteStatusResponse> {
        const response = await this.apiItemChangePartialCompleteStatusPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates a new item (task or event)
     */
    async apiItemCreatePostRaw(requestParameters: ApiItemCreatePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ItemCreateResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-csrf-token"] = await this.configuration.apiKey("x-csrf-token"); // csrfTokenHeader authentication
        }

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['id'] != null) {
            formParams.append('id', requestParameters['id'] as any);
        }

        if (requestParameters['instanceID'] != null) {
            formParams.append('InstanceID', requestParameters['instanceID'] as any);
        }

        if (requestParameters['notes'] != null) {
            formParams.append('Notes', requestParameters['notes'] as any);
        }

        if (requestParameters['dueDateTime'] != null) {
            formParams.append('DueDateTime', (requestParameters['dueDateTime'] as any).toISOString());
        }

        if (requestParameters['startDateTime'] != null) {
            formParams.append('StartDateTime', (requestParameters['startDateTime'] as any).toISOString());
        }

        if (requestParameters['endDateTime'] != null) {
            formParams.append('EndDateTime', (requestParameters['endDateTime'] as any).toISOString());
        }

        if (requestParameters['dontStartUntil'] != null) {
            formParams.append('DontStartUntil', (requestParameters['dontStartUntil'] as any).toISOString());
        }

        if (requestParameters['timeZone'] != null) {
            formParams.append('TimeZone', requestParameters['timeZone'] as any);
        }

        if (requestParameters['isAutoIgnored'] != null) {
            formParams.append('IsAutoIgnored', requestParameters['isAutoIgnored'] as any);
        }

        if (requestParameters['title'] != null) {
            formParams.append('Title', requestParameters['title'] as any);
        }

        if (requestParameters['itemType'] != null) {
            formParams.append('ItemType', requestParameters['itemType'] as any);
        }

        if (requestParameters['progressHours'] != null) {
            formParams.append('ProgressHours', requestParameters['progressHours'] as any);
        }

        if (requestParameters['progressMinutes'] != null) {
            formParams.append('ProgressMinutes', requestParameters['progressMinutes'] as any);
        }

        if (requestParameters['minLengthTotalMinutes'] != null) {
            formParams.append('minLengthTotalMinutes', requestParameters['minLengthTotalMinutes'] as any);
        }

        if (requestParameters['bufferTimeBeforeHours'] != null) {
            formParams.append('BufferTimeBeforeHours', requestParameters['bufferTimeBeforeHours'] as any);
        }

        if (requestParameters['bufferTimeBeforeMinutes'] != null) {
            formParams.append('BufferTimeBeforeMinutes', requestParameters['bufferTimeBeforeMinutes'] as any);
        }

        if (requestParameters['bufferTimeAfterHours'] != null) {
            formParams.append('BufferTimeAfterHours', requestParameters['bufferTimeAfterHours'] as any);
        }

        if (requestParameters['bufferTimeAfterMinutes'] != null) {
            formParams.append('BufferTimeAfterMinutes', requestParameters['bufferTimeAfterMinutes'] as any);
        }

        if (requestParameters['busy'] != null) {
            formParams.append('Busy', requestParameters['busy'] as any);
        }

        if (requestParameters['fixedTime'] != null) {
            formParams.append('FixedTime', requestParameters['fixedTime'] as any);
        }

        if (requestParameters['allDay'] != null) {
            formParams.append('AllDay', requestParameters['allDay'] as any);
        }

        if (requestParameters['repeatType'] != null) {
            formParams.append('RepeatType', requestParameters['repeatType'] as any);
        }

        if (requestParameters['interval'] != null) {
            formParams.append('Interval', requestParameters['interval'] as any);
        }

        if (requestParameters['sunday'] != null) {
            formParams.append('Sunday', requestParameters['sunday'] as any);
        }

        if (requestParameters['monday'] != null) {
            formParams.append('Monday', requestParameters['monday'] as any);
        }

        if (requestParameters['tuesday'] != null) {
            formParams.append('Tuesday', requestParameters['tuesday'] as any);
        }

        if (requestParameters['wednesday'] != null) {
            formParams.append('Wednesday', requestParameters['wednesday'] as any);
        }

        if (requestParameters['thursday'] != null) {
            formParams.append('Thursday', requestParameters['thursday'] as any);
        }

        if (requestParameters['friday'] != null) {
            formParams.append('Friday', requestParameters['friday'] as any);
        }

        if (requestParameters['saturday'] != null) {
            formParams.append('Saturday', requestParameters['saturday'] as any);
        }

        if (requestParameters['monthlyType'] != null) {
            formParams.append('MonthlyType', requestParameters['monthlyType'] as any);
        }

        if (requestParameters['dates'] != null) {
            formParams.append('Dates', requestParameters['dates'] as any);
        }

        if (requestParameters['monthOrdinal'] != null) {
            formParams.append('MonthOrdinal', requestParameters['monthOrdinal'] as any);
        }

        if (requestParameters['weekDay'] != null) {
            formParams.append('WeekDay', requestParameters['weekDay'] as any);
        }

        if (requestParameters['endRepeatType'] != null) {
            formParams.append('EndRepeatType', requestParameters['endRepeatType'] as any);
        }

        if (requestParameters['endRepeatDate'] != null) {
            formParams.append('EndRepeatDate', (requestParameters['endRepeatDate'] as any).toISOString());
        }

        if (requestParameters['numOccurrences'] != null) {
            formParams.append('NumOccurrences', requestParameters['numOccurrences'] as any);
        }

        if (requestParameters['priority'] != null) {
            formParams.append('priority', requestParameters['priority'] as any);
        }

        if (requestParameters['customColor'] != null) {
            formParams.append('customColor', requestParameters['customColor'] as any);
        }

        if (requestParameters['calendarId'] != null) {
            formParams.append('calendarId', requestParameters['calendarId'] as any);
        }

        if (requestParameters['timeProfileId'] != null) {
            formParams.append('timeProfileId', requestParameters['timeProfileId'] as any);
        }

        if (requestParameters['tagIds'] != null) {
            formParams.append('tagIds', requestParameters['tagIds'] as any);
        }

        if (requestParameters['location'] != null) {
            formParams.append('Location', requestParameters['location'] as any);
        }

        const response = await this.request({
            path: `/api/Item/Create`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ItemCreateResponseFromJSON(jsonValue));
    }

    /**
     * Creates a new item (task or event)
     */
    async apiItemCreatePost(requestParameters: ApiItemCreatePostRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ItemCreateResponse> {
        const response = await this.apiItemCreatePostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Gets an item for editing
     */
    async apiItemEditGetRaw(requestParameters: ApiItemEditGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ItemEditGetDataResponse>> {
        if (requestParameters['itemId'] == null) {
            throw new runtime.RequiredError(
                'itemId',
                'Required parameter "itemId" was null or undefined when calling apiItemEditGet().'
            );
        }

        if (requestParameters['instanceId'] == null) {
            throw new runtime.RequiredError(
                'instanceId',
                'Required parameter "instanceId" was null or undefined when calling apiItemEditGet().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['itemId'] != null) {
            queryParameters['itemId'] = requestParameters['itemId'];
        }

        if (requestParameters['instanceId'] != null) {
            queryParameters['instanceId'] = requestParameters['instanceId'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-csrf-token"] = await this.configuration.apiKey("x-csrf-token"); // csrfTokenHeader authentication
        }

        const response = await this.request({
            path: `/api/Item/Edit`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ItemEditGetDataResponseFromJSON(jsonValue));
    }

    /**
     * Gets an item for editing
     */
    async apiItemEditGet(requestParameters: ApiItemEditGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ItemEditGetDataResponse> {
        const response = await this.apiItemEditGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Edits an existing item
     */
    async apiItemEditPostRaw(requestParameters: ApiItemEditPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ItemEditResponse>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling apiItemEditPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-csrf-token"] = await this.configuration.apiKey("x-csrf-token"); // csrfTokenHeader authentication
        }

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['id'] != null) {
            formParams.append('id', requestParameters['id'] as any);
        }

        if (requestParameters['instanceID'] != null) {
            formParams.append('InstanceID', requestParameters['instanceID'] as any);
        }

        if (requestParameters['notes'] != null) {
            formParams.append('Notes', requestParameters['notes'] as any);
        }

        if (requestParameters['dueDateTime'] != null) {
            formParams.append('DueDateTime', (requestParameters['dueDateTime'] as any).toISOString());
        }

        if (requestParameters['startDateTime'] != null) {
            formParams.append('StartDateTime', (requestParameters['startDateTime'] as any).toISOString());
        }

        if (requestParameters['endDateTime'] != null) {
            formParams.append('EndDateTime', (requestParameters['endDateTime'] as any).toISOString());
        }

        if (requestParameters['dontStartUntil'] != null) {
            formParams.append('DontStartUntil', (requestParameters['dontStartUntil'] as any).toISOString());
        }

        if (requestParameters['timeZone'] != null) {
            formParams.append('TimeZone', requestParameters['timeZone'] as any);
        }

        if (requestParameters['isAutoIgnored'] != null) {
            formParams.append('IsAutoIgnored', requestParameters['isAutoIgnored'] as any);
        }

        if (requestParameters['title'] != null) {
            formParams.append('Title', requestParameters['title'] as any);
        }

        if (requestParameters['itemType'] != null) {
            formParams.append('ItemType', requestParameters['itemType'] as any);
        }

        if (requestParameters['progressHours'] != null) {
            formParams.append('ProgressHours', requestParameters['progressHours'] as any);
        }

        if (requestParameters['progressMinutes'] != null) {
            formParams.append('ProgressMinutes', requestParameters['progressMinutes'] as any);
        }

        if (requestParameters['minLengthTotalMinutes'] != null) {
            formParams.append('minLengthTotalMinutes', requestParameters['minLengthTotalMinutes'] as any);
        }

        if (requestParameters['bufferTimeBeforeHours'] != null) {
            formParams.append('BufferTimeBeforeHours', requestParameters['bufferTimeBeforeHours'] as any);
        }

        if (requestParameters['bufferTimeBeforeMinutes'] != null) {
            formParams.append('BufferTimeBeforeMinutes', requestParameters['bufferTimeBeforeMinutes'] as any);
        }

        if (requestParameters['bufferTimeAfterHours'] != null) {
            formParams.append('BufferTimeAfterHours', requestParameters['bufferTimeAfterHours'] as any);
        }

        if (requestParameters['bufferTimeAfterMinutes'] != null) {
            formParams.append('BufferTimeAfterMinutes', requestParameters['bufferTimeAfterMinutes'] as any);
        }

        if (requestParameters['busy'] != null) {
            formParams.append('Busy', requestParameters['busy'] as any);
        }

        if (requestParameters['fixedTime'] != null) {
            formParams.append('FixedTime', requestParameters['fixedTime'] as any);
        }

        if (requestParameters['allDay'] != null) {
            formParams.append('AllDay', requestParameters['allDay'] as any);
        }

        if (requestParameters['repeatType'] != null) {
            formParams.append('RepeatType', requestParameters['repeatType'] as any);
        }

        if (requestParameters['interval'] != null) {
            formParams.append('Interval', requestParameters['interval'] as any);
        }

        if (requestParameters['sunday'] != null) {
            formParams.append('Sunday', requestParameters['sunday'] as any);
        }

        if (requestParameters['monday'] != null) {
            formParams.append('Monday', requestParameters['monday'] as any);
        }

        if (requestParameters['tuesday'] != null) {
            formParams.append('Tuesday', requestParameters['tuesday'] as any);
        }

        if (requestParameters['wednesday'] != null) {
            formParams.append('Wednesday', requestParameters['wednesday'] as any);
        }

        if (requestParameters['thursday'] != null) {
            formParams.append('Thursday', requestParameters['thursday'] as any);
        }

        if (requestParameters['friday'] != null) {
            formParams.append('Friday', requestParameters['friday'] as any);
        }

        if (requestParameters['saturday'] != null) {
            formParams.append('Saturday', requestParameters['saturday'] as any);
        }

        if (requestParameters['monthlyType'] != null) {
            formParams.append('MonthlyType', requestParameters['monthlyType'] as any);
        }

        if (requestParameters['dates'] != null) {
            formParams.append('Dates', requestParameters['dates'] as any);
        }

        if (requestParameters['monthOrdinal'] != null) {
            formParams.append('MonthOrdinal', requestParameters['monthOrdinal'] as any);
        }

        if (requestParameters['weekDay'] != null) {
            formParams.append('WeekDay', requestParameters['weekDay'] as any);
        }

        if (requestParameters['endRepeatType'] != null) {
            formParams.append('EndRepeatType', requestParameters['endRepeatType'] as any);
        }

        if (requestParameters['endRepeatDate'] != null) {
            formParams.append('EndRepeatDate', (requestParameters['endRepeatDate'] as any).toISOString());
        }

        if (requestParameters['numOccurrences'] != null) {
            formParams.append('NumOccurrences', requestParameters['numOccurrences'] as any);
        }

        if (requestParameters['priority'] != null) {
            formParams.append('priority', requestParameters['priority'] as any);
        }

        if (requestParameters['customColor'] != null) {
            formParams.append('customColor', requestParameters['customColor'] as any);
        }

        if (requestParameters['calendarId'] != null) {
            formParams.append('calendarId', requestParameters['calendarId'] as any);
        }

        if (requestParameters['timeProfileId'] != null) {
            formParams.append('timeProfileId', requestParameters['timeProfileId'] as any);
        }

        if (requestParameters['tagIds'] != null) {
            formParams.append('tagIds', requestParameters['tagIds'] as any);
        }

        if (requestParameters['location'] != null) {
            formParams.append('Location', requestParameters['location'] as any);
        }

        const response = await this.request({
            path: `/api/Item/Edit`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ItemEditResponseFromJSON(jsonValue));
    }

    /**
     * Edits an existing item
     */
    async apiItemEditPost(requestParameters: ApiItemEditPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ItemEditResponse> {
        const response = await this.apiItemEditPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Deletes multiple items or instances
     */
    async apiItemMultipleDeletePostRaw(requestParameters: ApiItemMultipleDeletePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MultipleDeleteResponse>> {
        if (requestParameters['serializedItemIdToInstanceIdsDict'] == null) {
            throw new runtime.RequiredError(
                'serializedItemIdToInstanceIdsDict',
                'Required parameter "serializedItemIdToInstanceIdsDict" was null or undefined when calling apiItemMultipleDeletePost().'
            );
        }

        if (requestParameters['deleteType'] == null) {
            throw new runtime.RequiredError(
                'deleteType',
                'Required parameter "deleteType" was null or undefined when calling apiItemMultipleDeletePost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-csrf-token"] = await this.configuration.apiKey("x-csrf-token"); // csrfTokenHeader authentication
        }

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['serializedItemIdToInstanceIdsDict'] != null) {
            formParams.append('serializedItemIdToInstanceIdsDict', requestParameters['serializedItemIdToInstanceIdsDict'] as any);
        }

        if (requestParameters['deleteType'] != null) {
            formParams.append('deleteType', requestParameters['deleteType'] as any);
        }

        const response = await this.request({
            path: `/api/Item/MultipleDelete`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => MultipleDeleteResponseFromJSON(jsonValue));
    }

    /**
     * Deletes multiple items or instances
     */
    async apiItemMultipleDeletePost(requestParameters: ApiItemMultipleDeletePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MultipleDeleteResponse> {
        const response = await this.apiItemMultipleDeletePostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Searches for items based on a query string and other filters.
     */
    async apiItemSearchGetRaw(requestParameters: ApiItemSearchGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SearchResponseWrapper>> {
        if (requestParameters['query'] == null) {
            throw new runtime.RequiredError(
                'query',
                'Required parameter "query" was null or undefined when calling apiItemSearchGet().'
            );
        }

        if (requestParameters['searchCompletedTasks'] == null) {
            throw new runtime.RequiredError(
                'searchCompletedTasks',
                'Required parameter "searchCompletedTasks" was null or undefined when calling apiItemSearchGet().'
            );
        }

        if (requestParameters['getItemsAfterCursor'] == null) {
            throw new runtime.RequiredError(
                'getItemsAfterCursor',
                'Required parameter "getItemsAfterCursor" was null or undefined when calling apiItemSearchGet().'
            );
        }

        if (requestParameters['takeFirst'] == null) {
            throw new runtime.RequiredError(
                'takeFirst',
                'Required parameter "takeFirst" was null or undefined when calling apiItemSearchGet().'
            );
        }

        if (requestParameters['batchSize'] == null) {
            throw new runtime.RequiredError(
                'batchSize',
                'Required parameter "batchSize" was null or undefined when calling apiItemSearchGet().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['query'] != null) {
            queryParameters['query'] = requestParameters['query'];
        }

        if (requestParameters['searchCompletedTasks'] != null) {
            queryParameters['searchCompletedTasks'] = requestParameters['searchCompletedTasks'];
        }

        if (requestParameters['getItemsAfterCursor'] != null) {
            queryParameters['getItemsAfterCursor'] = requestParameters['getItemsAfterCursor'];
        }

        if (requestParameters['takeFirst'] != null) {
            queryParameters['takeFirst'] = requestParameters['takeFirst'];
        }

        if (requestParameters['batchSize'] != null) {
            queryParameters['batchSize'] = requestParameters['batchSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["x-csrf-token"] = await this.configuration.apiKey("x-csrf-token"); // csrfTokenHeader authentication
        }

        const response = await this.request({
            path: `/api/item/search`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SearchResponseWrapperFromJSON(jsonValue));
    }

    /**
     * Searches for items based on a query string and other filters.
     */
    async apiItemSearchGet(requestParameters: ApiItemSearchGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SearchResponseWrapper> {
        const response = await this.apiItemSearchGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
